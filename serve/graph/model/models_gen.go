// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type MessageValue interface {
	IsMessageValue()
}

// `BankMsgSend` is a message with a message router of `bank` and a message type of `send`.
// `BankMsgSend` is the fund transfer tx message.
type BankMsgSend struct {
	// the bech32 address of the fund sender.
	FromAddress string `json:"from_address"`
	// the bech32 address of the fund receiver.
	ToAddress string `json:"to_address"`
	// the denomination and amount of fund sent ("<amount><denomination>").
	Amount string `json:"amount"`
}

func (BankMsgSend) IsMessageValue() {}

// `BankMsgSendInput` represents input parameters required when the message type is `send`.
type BankMsgSendInput struct {
	// the bech32 address of the fund sender.
	FromAddress *string `json:"from_address,omitempty"`
	// the bech32 address of the fund receiver.
	ToAddress *string `json:"to_address,omitempty"`
	// the denomination and amount of fund sent ("<amount><denomination>").
	Amount *string `json:"amount,omitempty"`
}

// Filters for querying Blocks within specified criteria related to their attributes.
type BlockFilter struct {
	// Minimum block height from which to start fetching Blocks, inclusive. If unspecified, there is no lower bound.
	FromHeight *int `json:"from_height,omitempty"`
	// Maximum block height up to which Blocks should be fetched, exclusive. If unspecified, there is no upper bound.
	ToHeight *int `json:"to_height,omitempty"`
	// Minimum timestamp from which to start fetching Blocks, inclusive. Blocks created at or after this time will be included.
	FromTime *time.Time `json:"from_time,omitempty"`
	// Maximum timestamp up to which to fetch Blocks, exclusive. Only Blocks created before this time are included.
	ToTime *time.Time `json:"to_time,omitempty"`
}

// `MemFile` is the metadata information tied to a single gno package / realm file
type MemFile struct {
	// the name of the source file.
	Name string `json:"Name"`
	// the content of the source file.
	Body string `json:"Body"`
}

// `MemFileInput` is the metadata information tied to a single gno package / realm file.
type MemFileInput struct {
	// the name of the source file.
	Name *string `json:"Name,omitempty"`
	// the content of the source file.
	Body *string `json:"Body,omitempty"`
}

// `MemPackage` is the metadata information tied to package / realm deployment.
type MemPackage struct {
	// the name of the package.
	Name string `json:"Name"`
	// the gno path of the package.
	Path string `json:"Path"`
	// the associated package gno source.
	Files []*MemFile `json:"Files,omitempty"`
}

// `MemPackageInput` represents a package stored in memory.
type MemPackageInput struct {
	// the name of the package.
	Name *string `json:"Name,omitempty"`
	// the gno path of the package.
	Path *string `json:"Path,omitempty"`
	// the associated package gno source.
	Files []*MemFileInput `json:"Files,omitempty"`
}

// `MsgAddPackage` is a message with a message router of `vm` and a message type of `add_package`.
// `MsgAddPackage` is the package deployment tx message.
type MsgAddPackage struct {
	// the package deployer.
	Creator string `json:"creator"`
	// the package being deployed.
	Package *MemPackage `json:"package"`
	// the amount of funds to be deposited at deployment, if any ("<amount><denomination>").
	Deposit string `json:"deposit"`
}

func (MsgAddPackage) IsMessageValue() {}

// `MsgAddPackageInput` represents input parameters required when the message type is `add_package`.
type MsgAddPackageInput struct {
	// the package deployer.
	Creator *string `json:"creator,omitempty"`
	// the package being deployed.
	Package *MemPackageInput `json:"package,omitempty"`
	// the amount of funds to be deposited at deployment, if any ("<amount><denomination>").
	Deposit *string `json:"deposit,omitempty"`
}

// `MsgCall` is a message with a message router of `vm` and a message type of `exec`.
// `MsgCall` is the method invocation tx message.
type MsgCall struct {
	Caller  string   `json:"caller"`
	Send    string   `json:"send"`
	PkgPath string   `json:"pkg_path"`
	Func    string   `json:"func"`
	Args    []string `json:"args,omitempty"`
}

func (MsgCall) IsMessageValue() {}

// `MsgCallInput` represents input parameters required when the message type is `exec`.
type MsgCallInput struct {
	// the bech32 address of the caller.
	Caller *string `json:"caller,omitempty"`
	// the amount of funds to be deposited to the package, if any ("<amount><denomination>").
	Send *string `json:"send,omitempty"`
	// the gno package path.
	PkgPath *string `json:"pkg_path,omitempty"`
	// the function name being invoked.
	Func *string `json:"func,omitempty"`
	// `args` are the arguments passed to the executed function.
	// Arguments are checked in the order of the argument array, and arguments that are not checked are left blank.
	Args []string `json:"args,omitempty"`
}

// `MsgRun` is a message with a message router of `vm` and a message type of `run`.
// `MsgRun is the execute arbitrary Gno code tx message`.
type MsgRun struct {
	// the bech32 address of the caller.
	Caller string `json:"caller"`
	// the amount of funds to be deposited to the package, if any ("<amount><denomination>").
	Send string `json:"send"`
	// the package being executed.
	Package *MemPackage `json:"package"`
}

func (MsgRun) IsMessageValue() {}

// `MsgRunInput` represents input parameters required when the message type is `run`.
type MsgRunInput struct {
	// the bech32 address of the caller.
	Caller *string `json:"caller,omitempty"`
	// the amount of funds to be deposited to the package, if any ("<amount><denomination>").
	Send *string `json:"send,omitempty"`
	// the package being executed.
	Package *MemPackageInput `json:"package,omitempty"`
}

// Root Query type to fetch data about Blocks and Transactions based on filters or retrieve the latest block height.
type Query struct {
}

// Subscriptions provide a way for clients to receive real-time updates about Transactions and Blocks based on specified filter criteria.
// Subscribers will only receive updates for events occurring after the subscription is established.
type Subscription struct {
}

// `TransactionBankMessageInput` represents input parameters required when the message router is `bank`.
type TransactionBankMessageInput struct {
	// send represents input parameters required when the message type is `send`.
	Send *BankMsgSendInput `json:"send,omitempty"`
}

// Filters for querying Transactions within specified criteria related to their execution and placement within Blocks.
type TransactionFilter struct {
	// Minimum block height from which to start fetching Transactions, inclusive. Aids in scoping the search to recent Transactions.
	FromBlockHeight *int `json:"from_block_height,omitempty"`
	// Maximum block height up to which Transactions should be fetched, exclusive. Helps in limiting the search to older Transactions.
	ToBlockHeight *int `json:"to_block_height,omitempty"`
	// Minimum Transaction index from which to start fetching, inclusive. Facilitates ordering in Transaction queries.
	FromIndex *int `json:"from_index,omitempty"`
	// Maximum Transaction index up to which to fetch, exclusive. Ensures a limit on the ordering range for Transaction queries.
	ToIndex *int `json:"to_index,omitempty"`
	// Minimum `gas_wanted` value to filter Transactions by, inclusive. Filters Transactions based on the minimum computational effort declared.
	FromGasWanted *int `json:"from_gas_wanted,omitempty"`
	// Maximum `gas_wanted` value for filtering Transactions, exclusive. Limits Transactions based on the declared computational effort.
	ToGasWanted *int `json:"to_gas_wanted,omitempty"`
	// Minimum `gas_used` value to filter Transactions by, inclusive. Selects Transactions based on the minimum computational effort actually used.
	FromGasUsed *int `json:"from_gas_used,omitempty"`
	// Maximum `gas_used` value for filtering Transactions, exclusive. Refines selection based on the computational effort actually consumed.
	ToGasUsed *int `json:"to_gas_used,omitempty"`
	// Hash from Transaction content in base64 encoding. If this filter is used, any other filter will be ignored.
	Hash *string `json:"hash,omitempty"`
	// Transaction's message to filter Transactions.
	Message *TransactionMessageInput `json:"message,omitempty"`
	// `memo` value to filter Transaction's memo.
	Memo *string `json:"memo,omitempty"`
}

// Input for filters by transaction message.
type TransactionMessageInput struct {
	// The type of transaction message.
	TypeURL *MessageType `json:"type_url,omitempty"`
	// The route of transaction message.
	Route *MessageRoute `json:"route,omitempty"`
	// `TransactionBankMessageInput` represents input parameters required when the message router is `bank`.
	BankParam *TransactionBankMessageInput `json:"bank_param,omitempty"`
	// `TransactionVmMessageInput` represents input parameters required when the message router is `vm`.
	VMParam *TransactionVMMessageInput `json:"vm_param,omitempty"`
}

// `TransactionVmMessageInput` represents input parameters required when the message router is `vm`.
type TransactionVMMessageInput struct {
	// `MsgCallInput` represents input parameters required when the message type is `exec`.
	MCall *MsgCallInput `json:"m_call,omitempty"`
	// `MsgAddPackageInput` represents input parameters required when the message type is `add_package`.
	MAddpkg *MsgAddPackageInput `json:"m_addpkg,omitempty"`
	// `MsgRunInput` represents input parameters required when the message type is `run`.
	MRun *MsgRunInput `json:"m_run,omitempty"`
}

type TxFee struct {
	// gas limit
	GasWanted int `json:"gas_wanted"`
	// gas fee details (<value><denomination>)
	GasFee int `json:"gas_fee"`
}

type MessageRoute string

const (
	MessageRouteVM   MessageRoute = "vm"
	MessageRouteBank MessageRoute = "bank"
)

var AllMessageRoute = []MessageRoute{
	MessageRouteVM,
	MessageRouteBank,
}

func (e MessageRoute) IsValid() bool {
	switch e {
	case MessageRouteVM, MessageRouteBank:
		return true
	}
	return false
}

func (e MessageRoute) String() string {
	return string(e)
}

func (e *MessageRoute) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MessageRoute(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MessageRoute", str)
	}
	return nil
}

func (e MessageRoute) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MessageType string

const (
	MessageTypeSend       MessageType = "send"
	MessageTypeExec       MessageType = "exec"
	MessageTypeAddPackage MessageType = "add_package"
	MessageTypeRun        MessageType = "run"
)

var AllMessageType = []MessageType{
	MessageTypeSend,
	MessageTypeExec,
	MessageTypeAddPackage,
	MessageTypeRun,
}

func (e MessageType) IsValid() bool {
	switch e {
	case MessageTypeSend, MessageTypeExec, MessageTypeAddPackage, MessageTypeRun:
		return true
	}
	return false
}

func (e MessageType) String() string {
	return string(e)
}

func (e *MessageType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MessageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MessageType", str)
	}
	return nil
}

func (e MessageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
