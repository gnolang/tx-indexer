// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/gnolang/tx-indexer/serve/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
	Filterable func(ctx context.Context, obj interface{}, next graphql.Resolver, extras []model.FilterableExtra) (res interface{}, err error)
}

type ComplexityRoot struct {
	BankMsgSend struct {
		Amount      func(childComplexity int) int
		FromAddress func(childComplexity int) int
		ToAddress   func(childComplexity int) int
	}

	Block struct {
		AppHash            func(childComplexity int) int
		AppVersion         func(childComplexity int) int
		ChainID            func(childComplexity int) int
		ConsensusHash      func(childComplexity int) int
		Hash               func(childComplexity int) int
		Height             func(childComplexity int) int
		LastBlockHash      func(childComplexity int) int
		LastCommitHash     func(childComplexity int) int
		LastResultsHash    func(childComplexity int) int
		NextValidatorsHash func(childComplexity int) int
		NumTxs             func(childComplexity int) int
		ProposerAddressRaw func(childComplexity int) int
		Time               func(childComplexity int) int
		TotalTxs           func(childComplexity int) int
		Txs                func(childComplexity int) int
		ValidatorsHash     func(childComplexity int) int
		Version            func(childComplexity int) int
	}

	BlockTransaction struct {
		ContentRaw func(childComplexity int) int
		Fee        func(childComplexity int) int
		Hash       func(childComplexity int) int
		Memo       func(childComplexity int) int
	}

	Coin struct {
		Amount func(childComplexity int) int
		Denom  func(childComplexity int) int
	}

	GnoEvent struct {
		Attrs   func(childComplexity int) int
		Func    func(childComplexity int) int
		PkgPath func(childComplexity int) int
		Type    func(childComplexity int) int
	}

	GnoEventAttribute struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	MemFile struct {
		Body func(childComplexity int) int
		Name func(childComplexity int) int
	}

	MemPackage struct {
		Files func(childComplexity int) int
		Name  func(childComplexity int) int
		Path  func(childComplexity int) int
	}

	MsgAddPackage struct {
		Creator    func(childComplexity int) int
		Deposit    func(childComplexity int) int
		MaxDeposit func(childComplexity int) int
		Package    func(childComplexity int) int
		Send       func(childComplexity int) int
	}

	MsgCall struct {
		Args       func(childComplexity int) int
		Caller     func(childComplexity int) int
		Func       func(childComplexity int) int
		MaxDeposit func(childComplexity int) int
		PkgPath    func(childComplexity int) int
		Send       func(childComplexity int) int
	}

	MsgRun struct {
		Caller     func(childComplexity int) int
		MaxDeposit func(childComplexity int) int
		Package    func(childComplexity int) int
		Send       func(childComplexity int) int
	}

	Query struct {
		Blocks            func(childComplexity int, filter model.BlockFilter) int
		GetBlocks         func(childComplexity int, where model.FilterBlock, order *model.BlockOrder) int
		GetTransactions   func(childComplexity int, where model.FilterTransaction, order *model.TransactionOrder) int
		LatestBlockHeight func(childComplexity int) int
		Transactions      func(childComplexity int, filter model.TransactionFilter) int
	}

	Subscription struct {
		Blocks          func(childComplexity int, filter model.BlockFilter) int
		GetBlocks       func(childComplexity int, where model.FilterBlock) int
		GetTransactions func(childComplexity int, where model.FilterTransaction) int
		Transactions    func(childComplexity int, filter model.TransactionFilter) int
	}

	Transaction struct {
		BlockHeight func(childComplexity int) int
		ContentRaw  func(childComplexity int) int
		GasFee      func(childComplexity int) int
		GasUsed     func(childComplexity int) int
		GasWanted   func(childComplexity int) int
		Hash        func(childComplexity int) int
		Index       func(childComplexity int) int
		Memo        func(childComplexity int) int
		Messages    func(childComplexity int) int
		Response    func(childComplexity int) int
		Success     func(childComplexity int) int
	}

	TransactionMessage struct {
		Route   func(childComplexity int) int
		TypeURL func(childComplexity int) int
		Value   func(childComplexity int) int
	}

	TransactionResponse struct {
		Data   func(childComplexity int) int
		Error  func(childComplexity int) int
		Events func(childComplexity int) int
		Info   func(childComplexity int) int
		Log    func(childComplexity int) int
	}

	TxFee struct {
		GasFee    func(childComplexity int) int
		GasWanted func(childComplexity int) int
	}

	UnexpectedMessage struct {
		Raw func(childComplexity int) int
	}

	UnknownEvent struct {
		Value func(childComplexity int) int
	}
}

type QueryResolver interface {
	Transactions(ctx context.Context, filter model.TransactionFilter) ([]*model.Transaction, error)
	Blocks(ctx context.Context, filter model.BlockFilter) ([]*model.Block, error)
	LatestBlockHeight(ctx context.Context) (int, error)
	GetBlocks(ctx context.Context, where model.FilterBlock, order *model.BlockOrder) ([]*model.Block, error)
	GetTransactions(ctx context.Context, where model.FilterTransaction, order *model.TransactionOrder) ([]*model.Transaction, error)
}
type SubscriptionResolver interface {
	Transactions(ctx context.Context, filter model.TransactionFilter) (<-chan *model.Transaction, error)
	Blocks(ctx context.Context, filter model.BlockFilter) (<-chan *model.Block, error)
	GetTransactions(ctx context.Context, where model.FilterTransaction) (<-chan *model.Transaction, error)
	GetBlocks(ctx context.Context, where model.FilterBlock) (<-chan *model.Block, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "BankMsgSend.amount":
		if e.complexity.BankMsgSend.Amount == nil {
			break
		}

		return e.complexity.BankMsgSend.Amount(childComplexity), true

	case "BankMsgSend.from_address":
		if e.complexity.BankMsgSend.FromAddress == nil {
			break
		}

		return e.complexity.BankMsgSend.FromAddress(childComplexity), true

	case "BankMsgSend.to_address":
		if e.complexity.BankMsgSend.ToAddress == nil {
			break
		}

		return e.complexity.BankMsgSend.ToAddress(childComplexity), true

	case "Block.app_hash":
		if e.complexity.Block.AppHash == nil {
			break
		}

		return e.complexity.Block.AppHash(childComplexity), true

	case "Block.app_version":
		if e.complexity.Block.AppVersion == nil {
			break
		}

		return e.complexity.Block.AppVersion(childComplexity), true

	case "Block.chain_id":
		if e.complexity.Block.ChainID == nil {
			break
		}

		return e.complexity.Block.ChainID(childComplexity), true

	case "Block.consensus_hash":
		if e.complexity.Block.ConsensusHash == nil {
			break
		}

		return e.complexity.Block.ConsensusHash(childComplexity), true

	case "Block.hash":
		if e.complexity.Block.Hash == nil {
			break
		}

		return e.complexity.Block.Hash(childComplexity), true

	case "Block.height":
		if e.complexity.Block.Height == nil {
			break
		}

		return e.complexity.Block.Height(childComplexity), true

	case "Block.last_block_hash":
		if e.complexity.Block.LastBlockHash == nil {
			break
		}

		return e.complexity.Block.LastBlockHash(childComplexity), true

	case "Block.last_commit_hash":
		if e.complexity.Block.LastCommitHash == nil {
			break
		}

		return e.complexity.Block.LastCommitHash(childComplexity), true

	case "Block.last_results_hash":
		if e.complexity.Block.LastResultsHash == nil {
			break
		}

		return e.complexity.Block.LastResultsHash(childComplexity), true

	case "Block.next_validators_hash":
		if e.complexity.Block.NextValidatorsHash == nil {
			break
		}

		return e.complexity.Block.NextValidatorsHash(childComplexity), true

	case "Block.num_txs":
		if e.complexity.Block.NumTxs == nil {
			break
		}

		return e.complexity.Block.NumTxs(childComplexity), true

	case "Block.proposer_address_raw":
		if e.complexity.Block.ProposerAddressRaw == nil {
			break
		}

		return e.complexity.Block.ProposerAddressRaw(childComplexity), true

	case "Block.time":
		if e.complexity.Block.Time == nil {
			break
		}

		return e.complexity.Block.Time(childComplexity), true

	case "Block.total_txs":
		if e.complexity.Block.TotalTxs == nil {
			break
		}

		return e.complexity.Block.TotalTxs(childComplexity), true

	case "Block.txs":
		if e.complexity.Block.Txs == nil {
			break
		}

		return e.complexity.Block.Txs(childComplexity), true

	case "Block.validators_hash":
		if e.complexity.Block.ValidatorsHash == nil {
			break
		}

		return e.complexity.Block.ValidatorsHash(childComplexity), true

	case "Block.version":
		if e.complexity.Block.Version == nil {
			break
		}

		return e.complexity.Block.Version(childComplexity), true

	case "BlockTransaction.content_raw":
		if e.complexity.BlockTransaction.ContentRaw == nil {
			break
		}

		return e.complexity.BlockTransaction.ContentRaw(childComplexity), true

	case "BlockTransaction.fee":
		if e.complexity.BlockTransaction.Fee == nil {
			break
		}

		return e.complexity.BlockTransaction.Fee(childComplexity), true

	case "BlockTransaction.hash":
		if e.complexity.BlockTransaction.Hash == nil {
			break
		}

		return e.complexity.BlockTransaction.Hash(childComplexity), true

	case "BlockTransaction.memo":
		if e.complexity.BlockTransaction.Memo == nil {
			break
		}

		return e.complexity.BlockTransaction.Memo(childComplexity), true

	case "Coin.amount":
		if e.complexity.Coin.Amount == nil {
			break
		}

		return e.complexity.Coin.Amount(childComplexity), true

	case "Coin.denom":
		if e.complexity.Coin.Denom == nil {
			break
		}

		return e.complexity.Coin.Denom(childComplexity), true

	case "GnoEvent.attrs":
		if e.complexity.GnoEvent.Attrs == nil {
			break
		}

		return e.complexity.GnoEvent.Attrs(childComplexity), true

	case "GnoEvent.func":
		if e.complexity.GnoEvent.Func == nil {
			break
		}

		return e.complexity.GnoEvent.Func(childComplexity), true

	case "GnoEvent.pkg_path":
		if e.complexity.GnoEvent.PkgPath == nil {
			break
		}

		return e.complexity.GnoEvent.PkgPath(childComplexity), true

	case "GnoEvent.type":
		if e.complexity.GnoEvent.Type == nil {
			break
		}

		return e.complexity.GnoEvent.Type(childComplexity), true

	case "GnoEventAttribute.key":
		if e.complexity.GnoEventAttribute.Key == nil {
			break
		}

		return e.complexity.GnoEventAttribute.Key(childComplexity), true

	case "GnoEventAttribute.value":
		if e.complexity.GnoEventAttribute.Value == nil {
			break
		}

		return e.complexity.GnoEventAttribute.Value(childComplexity), true

	case "MemFile.body":
		if e.complexity.MemFile.Body == nil {
			break
		}

		return e.complexity.MemFile.Body(childComplexity), true

	case "MemFile.name":
		if e.complexity.MemFile.Name == nil {
			break
		}

		return e.complexity.MemFile.Name(childComplexity), true

	case "MemPackage.files":
		if e.complexity.MemPackage.Files == nil {
			break
		}

		return e.complexity.MemPackage.Files(childComplexity), true

	case "MemPackage.name":
		if e.complexity.MemPackage.Name == nil {
			break
		}

		return e.complexity.MemPackage.Name(childComplexity), true

	case "MemPackage.path":
		if e.complexity.MemPackage.Path == nil {
			break
		}

		return e.complexity.MemPackage.Path(childComplexity), true

	case "MsgAddPackage.creator":
		if e.complexity.MsgAddPackage.Creator == nil {
			break
		}

		return e.complexity.MsgAddPackage.Creator(childComplexity), true

	case "MsgAddPackage.deposit":
		if e.complexity.MsgAddPackage.Deposit == nil {
			break
		}

		return e.complexity.MsgAddPackage.Deposit(childComplexity), true

	case "MsgAddPackage.max_deposit":
		if e.complexity.MsgAddPackage.MaxDeposit == nil {
			break
		}

		return e.complexity.MsgAddPackage.MaxDeposit(childComplexity), true

	case "MsgAddPackage.package":
		if e.complexity.MsgAddPackage.Package == nil {
			break
		}

		return e.complexity.MsgAddPackage.Package(childComplexity), true

	case "MsgAddPackage.send":
		if e.complexity.MsgAddPackage.Send == nil {
			break
		}

		return e.complexity.MsgAddPackage.Send(childComplexity), true

	case "MsgCall.args":
		if e.complexity.MsgCall.Args == nil {
			break
		}

		return e.complexity.MsgCall.Args(childComplexity), true

	case "MsgCall.caller":
		if e.complexity.MsgCall.Caller == nil {
			break
		}

		return e.complexity.MsgCall.Caller(childComplexity), true

	case "MsgCall.func":
		if e.complexity.MsgCall.Func == nil {
			break
		}

		return e.complexity.MsgCall.Func(childComplexity), true

	case "MsgCall.max_deposit":
		if e.complexity.MsgCall.MaxDeposit == nil {
			break
		}

		return e.complexity.MsgCall.MaxDeposit(childComplexity), true

	case "MsgCall.pkg_path":
		if e.complexity.MsgCall.PkgPath == nil {
			break
		}

		return e.complexity.MsgCall.PkgPath(childComplexity), true

	case "MsgCall.send":
		if e.complexity.MsgCall.Send == nil {
			break
		}

		return e.complexity.MsgCall.Send(childComplexity), true

	case "MsgRun.caller":
		if e.complexity.MsgRun.Caller == nil {
			break
		}

		return e.complexity.MsgRun.Caller(childComplexity), true

	case "MsgRun.max_deposit":
		if e.complexity.MsgRun.MaxDeposit == nil {
			break
		}

		return e.complexity.MsgRun.MaxDeposit(childComplexity), true

	case "MsgRun.package":
		if e.complexity.MsgRun.Package == nil {
			break
		}

		return e.complexity.MsgRun.Package(childComplexity), true

	case "MsgRun.send":
		if e.complexity.MsgRun.Send == nil {
			break
		}

		return e.complexity.MsgRun.Send(childComplexity), true

	case "Query.blocks":
		if e.complexity.Query.Blocks == nil {
			break
		}

		args, err := ec.field_Query_blocks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Blocks(childComplexity, args["filter"].(model.BlockFilter)), true

	case "Query.getBlocks":
		if e.complexity.Query.GetBlocks == nil {
			break
		}

		args, err := ec.field_Query_getBlocks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBlocks(childComplexity, args["where"].(model.FilterBlock), args["order"].(*model.BlockOrder)), true

	case "Query.getTransactions":
		if e.complexity.Query.GetTransactions == nil {
			break
		}

		args, err := ec.field_Query_getTransactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetTransactions(childComplexity, args["where"].(model.FilterTransaction), args["order"].(*model.TransactionOrder)), true

	case "Query.latestBlockHeight":
		if e.complexity.Query.LatestBlockHeight == nil {
			break
		}

		return e.complexity.Query.LatestBlockHeight(childComplexity), true

	case "Query.transactions":
		if e.complexity.Query.Transactions == nil {
			break
		}

		args, err := ec.field_Query_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Transactions(childComplexity, args["filter"].(model.TransactionFilter)), true

	case "Subscription.blocks":
		if e.complexity.Subscription.Blocks == nil {
			break
		}

		args, err := ec.field_Subscription_blocks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Blocks(childComplexity, args["filter"].(model.BlockFilter)), true

	case "Subscription.getBlocks":
		if e.complexity.Subscription.GetBlocks == nil {
			break
		}

		args, err := ec.field_Subscription_getBlocks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetBlocks(childComplexity, args["where"].(model.FilterBlock)), true

	case "Subscription.getTransactions":
		if e.complexity.Subscription.GetTransactions == nil {
			break
		}

		args, err := ec.field_Subscription_getTransactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.GetTransactions(childComplexity, args["where"].(model.FilterTransaction)), true

	case "Subscription.transactions":
		if e.complexity.Subscription.Transactions == nil {
			break
		}

		args, err := ec.field_Subscription_transactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Transactions(childComplexity, args["filter"].(model.TransactionFilter)), true

	case "Transaction.block_height":
		if e.complexity.Transaction.BlockHeight == nil {
			break
		}

		return e.complexity.Transaction.BlockHeight(childComplexity), true

	case "Transaction.content_raw":
		if e.complexity.Transaction.ContentRaw == nil {
			break
		}

		return e.complexity.Transaction.ContentRaw(childComplexity), true

	case "Transaction.gas_fee":
		if e.complexity.Transaction.GasFee == nil {
			break
		}

		return e.complexity.Transaction.GasFee(childComplexity), true

	case "Transaction.gas_used":
		if e.complexity.Transaction.GasUsed == nil {
			break
		}

		return e.complexity.Transaction.GasUsed(childComplexity), true

	case "Transaction.gas_wanted":
		if e.complexity.Transaction.GasWanted == nil {
			break
		}

		return e.complexity.Transaction.GasWanted(childComplexity), true

	case "Transaction.hash":
		if e.complexity.Transaction.Hash == nil {
			break
		}

		return e.complexity.Transaction.Hash(childComplexity), true

	case "Transaction.index":
		if e.complexity.Transaction.Index == nil {
			break
		}

		return e.complexity.Transaction.Index(childComplexity), true

	case "Transaction.memo":
		if e.complexity.Transaction.Memo == nil {
			break
		}

		return e.complexity.Transaction.Memo(childComplexity), true

	case "Transaction.messages":
		if e.complexity.Transaction.Messages == nil {
			break
		}

		return e.complexity.Transaction.Messages(childComplexity), true

	case "Transaction.response":
		if e.complexity.Transaction.Response == nil {
			break
		}

		return e.complexity.Transaction.Response(childComplexity), true

	case "Transaction.success":
		if e.complexity.Transaction.Success == nil {
			break
		}

		return e.complexity.Transaction.Success(childComplexity), true

	case "TransactionMessage.route":
		if e.complexity.TransactionMessage.Route == nil {
			break
		}

		return e.complexity.TransactionMessage.Route(childComplexity), true

	case "TransactionMessage.typeUrl":
		if e.complexity.TransactionMessage.TypeURL == nil {
			break
		}

		return e.complexity.TransactionMessage.TypeURL(childComplexity), true

	case "TransactionMessage.value":
		if e.complexity.TransactionMessage.Value == nil {
			break
		}

		return e.complexity.TransactionMessage.Value(childComplexity), true

	case "TransactionResponse.data":
		if e.complexity.TransactionResponse.Data == nil {
			break
		}

		return e.complexity.TransactionResponse.Data(childComplexity), true

	case "TransactionResponse.error":
		if e.complexity.TransactionResponse.Error == nil {
			break
		}

		return e.complexity.TransactionResponse.Error(childComplexity), true

	case "TransactionResponse.events":
		if e.complexity.TransactionResponse.Events == nil {
			break
		}

		return e.complexity.TransactionResponse.Events(childComplexity), true

	case "TransactionResponse.info":
		if e.complexity.TransactionResponse.Info == nil {
			break
		}

		return e.complexity.TransactionResponse.Info(childComplexity), true

	case "TransactionResponse.log":
		if e.complexity.TransactionResponse.Log == nil {
			break
		}

		return e.complexity.TransactionResponse.Log(childComplexity), true

	case "TxFee.gas_fee":
		if e.complexity.TxFee.GasFee == nil {
			break
		}

		return e.complexity.TxFee.GasFee(childComplexity), true

	case "TxFee.gas_wanted":
		if e.complexity.TxFee.GasWanted == nil {
			break
		}

		return e.complexity.TxFee.GasWanted(childComplexity), true

	case "UnexpectedMessage.raw":
		if e.complexity.UnexpectedMessage.Raw == nil {
			break
		}

		return e.complexity.UnexpectedMessage.Raw(childComplexity), true

	case "UnknownEvent.value":
		if e.complexity.UnknownEvent.Value == nil {
			break
		}

		return e.complexity.UnknownEvent.Value(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAmountInput,
		ec.unmarshalInputBankMsgSendInput,
		ec.unmarshalInputBlockFilter,
		ec.unmarshalInputBlockOrder,
		ec.unmarshalInputEventAttributeInput,
		ec.unmarshalInputEventInput,
		ec.unmarshalInputFilterBankMsgSend,
		ec.unmarshalInputFilterBlock,
		ec.unmarshalInputFilterBlockTransaction,
		ec.unmarshalInputFilterBoolean,
		ec.unmarshalInputFilterCoin,
		ec.unmarshalInputFilterEvent,
		ec.unmarshalInputFilterGnoEvent,
		ec.unmarshalInputFilterGnoEventAttribute,
		ec.unmarshalInputFilterInt,
		ec.unmarshalInputFilterMemFile,
		ec.unmarshalInputFilterMemPackage,
		ec.unmarshalInputFilterMessageValue,
		ec.unmarshalInputFilterMsgAddPackage,
		ec.unmarshalInputFilterMsgCall,
		ec.unmarshalInputFilterMsgRun,
		ec.unmarshalInputFilterString,
		ec.unmarshalInputFilterTime,
		ec.unmarshalInputFilterTransaction,
		ec.unmarshalInputFilterTransactionMessage,
		ec.unmarshalInputFilterTransactionResponse,
		ec.unmarshalInputFilterTxFee,
		ec.unmarshalInputFilterUnknownEvent,
		ec.unmarshalInputMemFileInput,
		ec.unmarshalInputMemPackageInput,
		ec.unmarshalInputMsgAddPackageInput,
		ec.unmarshalInputMsgCallInput,
		ec.unmarshalInputMsgRunInput,
		ec.unmarshalInputNestedFilterBankMsgSend,
		ec.unmarshalInputNestedFilterBlockTransaction,
		ec.unmarshalInputNestedFilterCoin,
		ec.unmarshalInputNestedFilterEvent,
		ec.unmarshalInputNestedFilterGnoEvent,
		ec.unmarshalInputNestedFilterGnoEventAttribute,
		ec.unmarshalInputNestedFilterMemFile,
		ec.unmarshalInputNestedFilterMemPackage,
		ec.unmarshalInputNestedFilterMessageValue,
		ec.unmarshalInputNestedFilterMsgAddPackage,
		ec.unmarshalInputNestedFilterMsgCall,
		ec.unmarshalInputNestedFilterMsgRun,
		ec.unmarshalInputNestedFilterTransactionMessage,
		ec.unmarshalInputNestedFilterTransactionResponse,
		ec.unmarshalInputNestedFilterTxFee,
		ec.unmarshalInputNestedFilterUnknownEvent,
		ec.unmarshalInputTransactionBankMessageInput,
		ec.unmarshalInputTransactionFilter,
		ec.unmarshalInputTransactionMessageInput,
		ec.unmarshalInputTransactionOrder,
		ec.unmarshalInputTransactionVmMessageInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../all", Input: `directive @filterable(
	"""
	Add extra functionality to this field apart from the filtering capabilities.
	"""
	extras: [FilterableExtra!]
) on FIELD_DEFINITION
"""
` + "`" + `AmountInput` + "`" + ` is a range of token quantities to filter by.
"""
input AmountInput {
	"""
	The minimum quantity of tokens to check for.
	"""
	from: Int
	"""
	The maximum quantity of tokens to check for.
	"""
	to: Int
	"""
	Filter by token's denomination.
	If set to an empty string, it will get an empty value.
	"""
	denomination: String
}
"""
` + "`" + `BankMsgSend` + "`" + ` is a message with a message router of ` + "`" + `bank` + "`" + ` and a message type of ` + "`" + `send` + "`" + `.
` + "`" + `BankMsgSend` + "`" + ` is the fund transfer tx message.
"""
type BankMsgSend {
	"""
	the bech32 address of the fund sender.
	ex) ` + "`" + `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5` + "`" + `
	"""
	from_address: String! @filterable
	"""
	the bech32 address of the fund receiver.
	ex) ` + "`" + `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5` + "`" + `
	"""
	to_address: String! @filterable
	"""
	the denomination and amount of fund sent ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	amount: String! @filterable
}
"""
` + "`" + `BankMsgSendInput` + "`" + ` represents input parameters required when the message type is ` + "`" + `send` + "`" + `.
"""
input BankMsgSendInput {
	"""
	the bech32 address of the fund sender.
	You can filter by the fund sender address.
	ex) ` + "`" + `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5` + "`" + `
	"""
	from_address: String
	"""
	the bech32 address of the fund receiver.
	You can filter by the fund receiver address.
	ex) ` + "`" + `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5` + "`" + `
	"""
	to_address: String
	"""
	the denomination and amount of fund sent ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	amount: AmountInput
}
"""
Represents a blockchain block with various attributes detailing its creation and content.
"""
type Block {
	"""
	A unique identifier for the block, determined by the blockchain's header.
	It is computed as a Merkle tree from the header.
	"""
	hash: String! @filterable
	"""
	A unique identifier for the Block determined by its position in the blockchain.
	This integer is strictly increasing with each new Block.
	"""
	height: Int! @filterable(extras: [MINMAX])
	"""
	The software version of the node that created this Block, indicating the specific
	implementation and versioning of the blockchain protocol used.
	"""
	version: String! @filterable
	"""
	An identifier for the specific blockchain network this Block belongs to. Helps in
	distinguishing between different networks like mainnet, testnet, etc.
	"""
	chain_id: String! @filterable
	"""
	The timestamp at which this Block was proposed and finalized in the blockchain. Represented in UTC.
	"""
	time: Time! @filterable
	"""
	The number of transactions this Block belongs to.
	"""
	num_txs: Int! @filterable
	"""
	The total number of transactions that have occurred up to this block.
	Indicates the total number of transactions that have occurred up to this point, even if there are no transactions in this block.
	"""
	total_txs: Int! @filterable
	"""
	The application's version.
	"""
	app_version: String! @filterable
	"""
	The last committed block hash.
	"""
	last_block_hash: String! @filterable
	"""
	Commit hash from validators from the last block.
	"""
	last_commit_hash: String! @filterable
	"""
	Validators for the current block.
	"""
	validators_hash: String! @filterable
	"""
	Validators for the next block.
	"""
	next_validators_hash: String! @filterable
	"""
	Consensus params for current block.
	"""
	consensus_hash: String! @filterable
	"""
	State after txs from the previous block.
	"""
	app_hash: String! @filterable
	"""
	Root hash of all results from the txs from the previous block.
	"""
	last_results_hash: String! @filterable
	"""
	Encoded data representing the blockchain address of the proposer who submitted this Block.
	It is raw and requires decoding to be human-readable.
	"""
	proposer_address_raw: String! @filterable
	"""
	txs contains transactions included in the block.
	"""
	txs: [BlockTransaction]! @filterable
}
"""
Filters for querying Blocks within specified criteria related to their attributes.
"""
input BlockFilter {
	"""
	Minimum block height from which to start fetching Blocks, inclusive. If unspecified, there is no lower bound.
	"""
	from_height: Int
	"""
	Maximum block height up to which Blocks should be fetched, exclusive. If unspecified, there is no upper bound.
	"""
	to_height: Int
	"""
	Minimum timestamp from which to start fetching Blocks, inclusive. Blocks created at or after this time will be included.
	"""
	from_time: Time
	"""
	Maximum timestamp up to which to fetch Blocks, exclusive. Only Blocks created before this time are included.
	"""
	to_time: Time
}
input BlockOrder {
	height: Order!
}
"""
Defines a transaction within a block, its execution specifics and content.
"""
type BlockTransaction {
	"""
	Hash computes the TMHASH hash of the wire encoded transaction.
	"""
	hash: String! @filterable
	"""
	Fee information for the transaction.
	"""
	fee: TxFee! @filterable
	"""
	` + "`" + `memo` + "`" + ` are string information stored within a transaction.
	` + "`" + `memo` + "`" + ` can be utilized to find or distinguish transactions.
	For example, when trading a specific exchange, you would utilize the memo field of the transaction.
	"""
	memo: String! @filterable
	"""
	The payload of the Transaction in a raw format, typically containing the instructions and any data necessary for execution.
	"""
	content_raw: String!
}
"""
Define the quantity and denomination of a coin.
"""
type Coin {
	"""
	The amount of coins.
	"""
	amount: Int! @filterable
	"""
	The denomination of the coin.
	"""
	denom: String! @filterable
}
union Event = GnoEvent | UnknownEvent
"""
Transaction event's attribute to filter transaction.
"EventAttributeInput" can be configured as a filter with a event attribute's ` + "`" + `key` + "`" + ` and ` + "`" + `value` + "`" + `.
"""
input EventAttributeInput {
	"""
	` + "`" + `key` + "`" + ` is the key of the event attribute.
	"""
	key: String
	"""
	` + "`" + `value` + "`" + ` is the value of the event attribute.
	"""
	value: String
}
"""
Transaction's event to filter transactions.
"EventInput" can be configured as a filter with a transaction event's ` + "`" + `type` + "`" + ` and ` + "`" + `pkg_path` + "`" + ` and ` + "`" + `func` + "`" + `, and ` + "`" + `attrs` + "`" + `.
"""
input EventInput {
	"""
	` + "`" + `type` + "`" + ` is the type of transaction event emitted.
	"""
	type: String
	"""
	` + "`" + `pkg_path` + "`" + ` is the path to the package that emitted the event.
	"""
	pkg_path: String
	"""
	` + "`" + `func` + "`" + ` is the name of the function that emitted the event.
	"""
	func: String
	"""
	` + "`" + `attrs` + "`" + ` filters transactions whose events contain attributes.
	` + "`" + `attrs` + "`" + ` is entered as an array and works exclusively.
	ex) ` + "`" + `attrs[0] || attrs[1] || attrs[2]` + "`" + `
	"""
	attrs: [EventAttributeInput!]
}
"""
filter for BankMsgSend objects
"""
input FilterBankMsgSend {
	"""
	logical operator for BankMsgSend that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterBankMsgSend]
	"""
	logical operator for BankMsgSend that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterBankMsgSend]
	"""
	logical operator for BankMsgSend that will reverse conditions.
	"""
	_not: FilterBankMsgSend
	"""
	filter for from_address field.
	"""
	from_address: FilterString
	"""
	filter for to_address field.
	"""
	to_address: FilterString
	"""
	filter for amount field.
	"""
	amount: FilterString
}
"""
filter for Block objects
"""
input FilterBlock {
	"""
	logical operator for Block that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterBlock]
	"""
	logical operator for Block that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterBlock]
	"""
	logical operator for Block that will reverse conditions.
	"""
	_not: FilterBlock
	"""
	filter for hash field.
	"""
	hash: FilterString
	"""
	filter for height field.
	"""
	height: FilterInt
	"""
	filter for version field.
	"""
	version: FilterString
	"""
	filter for chain_id field.
	"""
	chain_id: FilterString
	"""
	filter for time field.
	"""
	time: FilterTime
	"""
	filter for num_txs field.
	"""
	num_txs: FilterInt
	"""
	filter for total_txs field.
	"""
	total_txs: FilterInt
	"""
	filter for app_version field.
	"""
	app_version: FilterString
	"""
	filter for last_block_hash field.
	"""
	last_block_hash: FilterString
	"""
	filter for last_commit_hash field.
	"""
	last_commit_hash: FilterString
	"""
	filter for validators_hash field.
	"""
	validators_hash: FilterString
	"""
	filter for next_validators_hash field.
	"""
	next_validators_hash: FilterString
	"""
	filter for consensus_hash field.
	"""
	consensus_hash: FilterString
	"""
	filter for app_hash field.
	"""
	app_hash: FilterString
	"""
	filter for last_results_hash field.
	"""
	last_results_hash: FilterString
	"""
	filter for proposer_address_raw field.
	"""
	proposer_address_raw: FilterString
	"""
	filter for txs field.
	"""
	txs: NestedFilterBlockTransaction
}
"""
filter for BlockTransaction objects
"""
input FilterBlockTransaction {
	"""
	logical operator for BlockTransaction that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterBlockTransaction]
	"""
	logical operator for BlockTransaction that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterBlockTransaction]
	"""
	logical operator for BlockTransaction that will reverse conditions.
	"""
	_not: FilterBlockTransaction
	"""
	filter for hash field.
	"""
	hash: FilterString
	"""
	filter for fee field.
	"""
	fee: NestedFilterTxFee
	"""
	filter for memo field.
	"""
	memo: FilterString
}
"""
Filter type for boolean fields. All added filters here are processed as AND operators.
"""
input FilterBoolean {
	"""
	Filter a boolean field checking if it exists or not.
	"""
	exists: Boolean
	"""
	Filter a boolean field checking if it is equals to the specified value.
	"""
	eq: Boolean
}
"""
filter for Coin objects
"""
input FilterCoin {
	"""
	logical operator for Coin that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterCoin]
	"""
	logical operator for Coin that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterCoin]
	"""
	logical operator for Coin that will reverse conditions.
	"""
	_not: FilterCoin
	"""
	filter for amount field.
	"""
	amount: FilterInt
	"""
	filter for denom field.
	"""
	denom: FilterString
}
"""
filter for Event objects
"""
input FilterEvent {
	"""
	logical operator for Event that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterEvent]
	"""
	logical operator for Event that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterEvent]
	"""
	logical operator for Event that will reverse conditions.
	"""
	_not: FilterEvent
	"""
	filter for GnoEvent union type.
	"""
	GnoEvent: NestedFilterGnoEvent
	"""
	filter for UnknownEvent union type.
	"""
	UnknownEvent: NestedFilterUnknownEvent
}
"""
filter for GnoEvent objects
"""
input FilterGnoEvent {
	"""
	logical operator for GnoEvent that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterGnoEvent]
	"""
	logical operator for GnoEvent that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterGnoEvent]
	"""
	logical operator for GnoEvent that will reverse conditions.
	"""
	_not: FilterGnoEvent
	"""
	filter for type field.
	"""
	type: FilterString
	"""
	filter for pkg_path field.
	"""
	pkg_path: FilterString
	"""
	filter for func field.
	"""
	func: FilterString
	"""
	filter for attrs field.
	"""
	attrs: NestedFilterGnoEventAttribute
}
"""
filter for GnoEventAttribute objects
"""
input FilterGnoEventAttribute {
	"""
	logical operator for GnoEventAttribute that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterGnoEventAttribute]
	"""
	logical operator for GnoEventAttribute that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterGnoEventAttribute]
	"""
	logical operator for GnoEventAttribute that will reverse conditions.
	"""
	_not: FilterGnoEventAttribute
	"""
	filter for key field.
	"""
	key: FilterString
	"""
	filter for value field.
	"""
	value: FilterString
}
"""
Filter type for number fields. All added filters here are processed as AND operators.
"""
input FilterInt {
	"""
	Filter a number field checking if it exists or not.
	"""
	exists: Boolean
	"""
	Filter a number field checking if it is equals to the specified value.
	"""
	eq: Int
	"""
	Filter a number field checking if it is greater than the specified value.
	"""
	gt: Int
	"""
	Filter a number field checking if it is less than the specified value.
	"""
	lt: Int
}
"""
filter for MemFile objects
"""
input FilterMemFile {
	"""
	logical operator for MemFile that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterMemFile]
	"""
	logical operator for MemFile that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterMemFile]
	"""
	logical operator for MemFile that will reverse conditions.
	"""
	_not: FilterMemFile
	"""
	filter for name field.
	"""
	name: FilterString
	"""
	filter for body field.
	"""
	body: FilterString
}
"""
filter for MemPackage objects
"""
input FilterMemPackage {
	"""
	logical operator for MemPackage that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterMemPackage]
	"""
	logical operator for MemPackage that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterMemPackage]
	"""
	logical operator for MemPackage that will reverse conditions.
	"""
	_not: FilterMemPackage
	"""
	filter for name field.
	"""
	name: FilterString
	"""
	filter for path field.
	"""
	path: FilterString
	"""
	filter for files field.
	"""
	files: NestedFilterMemFile
}
"""
filter for MessageValue objects
"""
input FilterMessageValue {
	"""
	logical operator for MessageValue that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterMessageValue]
	"""
	logical operator for MessageValue that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterMessageValue]
	"""
	logical operator for MessageValue that will reverse conditions.
	"""
	_not: FilterMessageValue
	"""
	filter for BankMsgSend union type.
	"""
	BankMsgSend: NestedFilterBankMsgSend
	"""
	filter for MsgCall union type.
	"""
	MsgCall: NestedFilterMsgCall
	"""
	filter for MsgAddPackage union type.
	"""
	MsgAddPackage: NestedFilterMsgAddPackage
	"""
	filter for MsgRun union type.
	"""
	MsgRun: NestedFilterMsgRun
}
"""
filter for MsgAddPackage objects
"""
input FilterMsgAddPackage {
	"""
	logical operator for MsgAddPackage that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterMsgAddPackage]
	"""
	logical operator for MsgAddPackage that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterMsgAddPackage]
	"""
	logical operator for MsgAddPackage that will reverse conditions.
	"""
	_not: FilterMsgAddPackage
	"""
	filter for creator field.
	"""
	creator: FilterString
	"""
	filter for package field.
	"""
	package: NestedFilterMemPackage
	"""
	filter for deposit field.
	"""
	deposit: FilterString
	"""
	filter for send field.
	"""
	send: FilterString
	"""
	filter for max_deposit field.
	"""
	max_deposit: FilterString
}
"""
filter for MsgCall objects
"""
input FilterMsgCall {
	"""
	logical operator for MsgCall that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterMsgCall]
	"""
	logical operator for MsgCall that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterMsgCall]
	"""
	logical operator for MsgCall that will reverse conditions.
	"""
	_not: FilterMsgCall
	"""
	filter for caller field.
	"""
	caller: FilterString
	"""
	filter for send field.
	"""
	send: FilterString
	"""
	filter for pkg_path field.
	"""
	pkg_path: FilterString
	"""
	filter for func field.
	"""
	func: FilterString
	"""
	filter for args field.
	"""
	args: FilterString
	"""
	filter for max_deposit field.
	"""
	max_deposit: FilterString
}
"""
filter for MsgRun objects
"""
input FilterMsgRun {
	"""
	logical operator for MsgRun that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterMsgRun]
	"""
	logical operator for MsgRun that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterMsgRun]
	"""
	logical operator for MsgRun that will reverse conditions.
	"""
	_not: FilterMsgRun
	"""
	filter for caller field.
	"""
	caller: FilterString
	"""
	filter for send field.
	"""
	send: FilterString
	"""
	filter for package field.
	"""
	package: NestedFilterMemPackage
	"""
	filter for max_deposit field.
	"""
	max_deposit: FilterString
}
"""
Filter type for string fields. It contains a variety of filter types for string types. All added filters here are processed as AND operators.
"""
input FilterString {
	"""
	Filter a string field checking if it exists or not.
	"""
	exists: Boolean
	"""
	Filter a string field checking if it is equals to the specified value.
	"""
	eq: String
	"""
	Filter a string field checking if it is like the specified value. You can use standard Go RegEx expressions here.
	"""
	like: String
}
"""
Filter type for time fields. All added filters here are processed as AND operators.
"""
input FilterTime {
	"""
	Filter a time field checking if it exists or not.
	"""
	exists: Boolean
	"""
	Filter a time field checking if it is equals to the specified value.
	"""
	eq: Time
	"""
	Filter a time field checking if it is before than the specified value.
	"""
	before: Time
	"""
	Filter a time field checking if it is after the specified value.
	"""
	after: Time
}
"""
filter for Transaction objects
"""
input FilterTransaction {
	"""
	logical operator for Transaction that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterTransaction]
	"""
	logical operator for Transaction that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterTransaction]
	"""
	logical operator for Transaction that will reverse conditions.
	"""
	_not: FilterTransaction
	"""
	filter for index field.
	"""
	index: FilterInt
	"""
	filter for hash field.
	"""
	hash: FilterString
	"""
	filter for success field.
	"""
	success: FilterBoolean
	"""
	filter for block_height field.
	"""
	block_height: FilterInt
	"""
	filter for gas_wanted field.
	"""
	gas_wanted: FilterInt
	"""
	filter for gas_used field.
	"""
	gas_used: FilterInt
	"""
	filter for gas_fee field.
	"""
	gas_fee: NestedFilterCoin
	"""
	filter for messages field.
	"""
	messages: NestedFilterTransactionMessage
	"""
	filter for memo field.
	"""
	memo: FilterString
	"""
	filter for response field.
	"""
	response: NestedFilterTransactionResponse
}
"""
filter for TransactionMessage objects
"""
input FilterTransactionMessage {
	"""
	logical operator for TransactionMessage that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterTransactionMessage]
	"""
	logical operator for TransactionMessage that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterTransactionMessage]
	"""
	logical operator for TransactionMessage that will reverse conditions.
	"""
	_not: FilterTransactionMessage
	"""
	filter for typeUrl field.
	"""
	typeUrl: FilterString
	"""
	filter for route field.
	"""
	route: FilterString
	"""
	filter for value field.
	"""
	value: NestedFilterMessageValue
}
"""
filter for TransactionResponse objects
"""
input FilterTransactionResponse {
	"""
	logical operator for TransactionResponse that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterTransactionResponse]
	"""
	logical operator for TransactionResponse that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterTransactionResponse]
	"""
	logical operator for TransactionResponse that will reverse conditions.
	"""
	_not: FilterTransactionResponse
	"""
	filter for log field.
	"""
	log: FilterString
	"""
	filter for info field.
	"""
	info: FilterString
	"""
	filter for error field.
	"""
	error: FilterString
	"""
	filter for data field.
	"""
	data: FilterString
	"""
	filter for events field.
	"""
	events: NestedFilterEvent
}
"""
filter for TxFee objects
"""
input FilterTxFee {
	"""
	logical operator for TxFee that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterTxFee]
	"""
	logical operator for TxFee that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterTxFee]
	"""
	logical operator for TxFee that will reverse conditions.
	"""
	_not: FilterTxFee
	"""
	filter for gas_wanted field.
	"""
	gas_wanted: FilterInt
	"""
	filter for gas_fee field.
	"""
	gas_fee: NestedFilterCoin
}
"""
filter for UnknownEvent objects
"""
input FilterUnknownEvent {
	"""
	logical operator for UnknownEvent that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [FilterUnknownEvent]
	"""
	logical operator for UnknownEvent that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [FilterUnknownEvent]
	"""
	logical operator for UnknownEvent that will reverse conditions.
	"""
	_not: FilterUnknownEvent
	"""
	filter for value field.
	"""
	value: FilterString
}
enum FilterableExtra {
	"""
	Get minimum and maximum value used on all the filters for this field.
	Useful when you need to do a range query for performance reasons.
	"""
	MINMAX
}
"""
` + "`" + `GnoEvent` + "`" + ` is the event information exported by the Gno VM.
It has ` + "`" + `type` + "`" + `, ` + "`" + `pkg_path` + "`" + `, ` + "`" + `func` + "`" + `, and ` + "`" + `attrs` + "`" + `.
"""
type GnoEvent {
	"""
	` + "`" + `type` + "`" + ` is the type of transaction event emitted.
	"""
	type: String! @filterable
	"""
	` + "`" + `pkg_path` + "`" + ` is the path to the package that emitted the event.
	"""
	pkg_path: String! @filterable
	"""
	` + "`" + `func` + "`" + ` is the name of the function that emitted the event.
	"""
	func: String! @filterable
	"""
	` + "`" + `attrs` + "`" + ` is the event's attribute information.
	"""
	attrs: [GnoEventAttribute!] @filterable
}
"""
` + "`" + `GnoEventAttribute` + "`" + ` is the attributes that the event has.
It has ` + "`" + `key` + "`" + ` and ` + "`" + `value` + "`" + `.
"""
type GnoEventAttribute {
	"""
	The key of the event attribute.
	"""
	key: String! @filterable
	"""
	The value of the event attribute.
	"""
	value: String! @filterable
}
"""
` + "`" + `MemFile` + "`" + ` is the metadata information tied to a single gno package / realm file
"""
type MemFile {
	"""
	the name of the source file.
	"""
	name: String! @filterable
	"""
	the content of the source file.
	"""
	body: String! @filterable
}
"""
` + "`" + `MemFileInput` + "`" + ` is the metadata information tied to a single gno package / realm file.
"""
input MemFileInput {
	"""
	the name of the source file.
	"""
	name: String
	"""
	the content of the source file.
	"""
	body: String
}
"""
` + "`" + `MemPackage` + "`" + ` is the metadata information tied to package / realm deployment.
"""
type MemPackage {
	"""
	the name of the package.
	"""
	name: String! @filterable
	"""
	the gno path of the package.
	"""
	path: String! @filterable
	"""
	the associated package gno source.
	"""
	files: [MemFile!] @filterable
}
"""
` + "`" + `MemPackageInput` + "`" + ` represents a package stored in memory.
"""
input MemPackageInput {
	"""
	the name of the package.
	"""
	name: String
	"""
	the gno path of the package.
	"""
	path: String
	"""
	the associated package gno source.
	"""
	files: [MemFileInput]
}
"""
` + "`" + `MessageRoute` + "`" + ` is route type of the transactional message.
` + "`" + `MessageRoute` + "`" + ` has the values of vm and bank.
"""
enum MessageRoute {
	vm
	bank
}
"""
` + "`" + `MessageType` + "`" + ` is message type of the transaction.
` + "`" + `MessageType` + "`" + ` has the values ` + "`" + `send` + "`" + `, ` + "`" + `exec` + "`" + `, ` + "`" + `add_package` + "`" + `, and ` + "`" + `run` + "`" + `.
"""
enum MessageType {
	"""
	The route value for this message type is ` + "`" + `bank` + "`" + `, and the value for transactional messages is ` + "`" + `BankMsgSend` + "`" + `.
	This is a transaction message used when sending native tokens.
	"""
	send
	"""
	The route value for this message type is ` + "`" + `vm` + "`" + `, and the value for transactional messages is ` + "`" + `MsgCall` + "`" + `.
	This is a transaction message that executes a function in realm or package that is deployed in the GNO chain.
	"""
	exec
	"""
	The route value for this message type is ` + "`" + `vm` + "`" + `, and the value for transactional messages is ` + "`" + `MsgAddPackage` + "`" + `.
	This is a transactional message that adds a package to the GNO chain.
	"""
	add_package
	"""
	The route value for this message type is ` + "`" + `vm` + "`" + `, and the value for transactional messages is ` + "`" + `MsgRun` + "`" + `.
	This is a transactional message that executes an arbitrary Gno-coded TX message.
	"""
	run
}
union MessageValue = BankMsgSend | MsgCall | MsgAddPackage | MsgRun | UnexpectedMessage
"""
` + "`" + `MsgAddPackage` + "`" + ` is a message with a message router of ` + "`" + `vm` + "`" + ` and a message type of ` + "`" + `add_package` + "`" + `.
` + "`" + `MsgAddPackage` + "`" + ` is the package deployment tx message.
"""
type MsgAddPackage {
	"""
	the bech32 address of the package deployer.
	ex) ` + "`" + `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5` + "`" + `
	"""
	creator: String! @filterable
	"""
	the package being deployed.
	"""
	package: MemPackage! @filterable
	"""
	the amount of funds to be deposited at deployment, if any ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	deposit: String! @filterable @deprecated(reason: "Use ` + "`" + `send` + "`" + ` instead.")
	"""
	the amount of funds to be deposited at deployment, if any ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	send: String! @filterable
	"""
	the maximum amount of funds to be deposited at deployment used for storage, if any ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	max_deposit: String! @filterable
}
"""
` + "`" + `MsgAddPackageInput` + "`" + ` represents input parameters required when the message type is ` + "`" + `add_package` + "`" + `.
"""
input MsgAddPackageInput {
	"""
	the bech32 address of the package deployer.
	You can filter by the package deployer's address.
	ex) ` + "`" + `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5` + "`" + `
	"""
	creator: String
	"""
	the package being deployed.
	"""
	package: MemPackageInput
	"""
	the amount of funds to be deposited at deployment, if any ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	deposit: AmountInput
}
"""
` + "`" + `MsgCall` + "`" + ` is a message with a message router of ` + "`" + `vm` + "`" + ` and a message type of ` + "`" + `exec` + "`" + `.
` + "`" + `MsgCall` + "`" + ` is the method invocation tx message.
"""
type MsgCall {
	"""
	the bech32 address of the function caller.
	ex) ` + "`" + `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5` + "`" + `
	"""
	caller: String! @filterable
	"""
	the amount of funds to be deposited to the package, if any ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	send: String! @filterable
	"""
	the gno package path.
	"""
	pkg_path: String! @filterable
	"""
	the function name being invoked.
	"""
	func: String! @filterable
	"""
	` + "`" + `args` + "`" + ` are the arguments passed to the executed function.
	"""
	args: [String!] @filterable
	"""
	the maximum amount of funds to be deposited used for storage, if any ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	max_deposit: String! @filterable
}
"""
` + "`" + `MsgCallInput` + "`" + ` represents input parameters required when the message type is ` + "`" + `exec` + "`" + `.
"""
input MsgCallInput {
	"""
	the bech32 address of the function caller.
	You can filter by the function caller's address.
	ex) ` + "`" + `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5` + "`" + `
	"""
	caller: String
	"""
	the amount of funds to be deposited to the package, if any ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	send: AmountInput
	"""
	the gno package path.
	"""
	pkg_path: String
	"""
	the function name being invoked.
	"""
	func: String
	"""
	` + "`" + `args` + "`" + ` are the arguments passed to the executed function.
	The arguments are checked in the order of the argument array and
	if they are empty strings, they are excluded from the filtering criteria.
	ex) ` + "`" + `["", "", "1"]` + "`" + ` <- Empty strings skip the condition.
	"""
	args: [String!]
}
"""
` + "`" + `MsgRun` + "`" + ` is a message with a message router of ` + "`" + `vm` + "`" + ` and a message type of ` + "`" + `run` + "`" + `.
` + "`" + `MsgRun is the execute arbitrary Gno code tx message` + "`" + `.
"""
type MsgRun {
	"""
	the bech32 address of the function caller.
	ex) ` + "`" + `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5` + "`" + `
	"""
	caller: String! @filterable
	"""
	the amount of funds to be deposited to the package, if any ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	send: String! @filterable
	"""
	the package being executed.
	"""
	package: MemPackage! @filterable
	"""
	the maximum amount of funds to be deposited used for storage, if any ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	max_deposit: String! @filterable
}
"""
` + "`" + `MsgRunInput` + "`" + ` represents input parameters required when the message type is ` + "`" + `run` + "`" + `.
"""
input MsgRunInput {
	"""
	the bech32 address of the function caller.
	You can filter by the function caller's address.
	ex) ` + "`" + `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5` + "`" + `
	"""
	caller: String
	"""
	the amount of funds to be deposited to the package, if any ("<amount><denomination>").
	ex) ` + "`" + `1000000ugnot` + "`" + `
	"""
	send: AmountInput
	"""
	the package being executed.
	"""
	package: MemPackageInput
}
"""
filter for BankMsgSend objects
"""
input NestedFilterBankMsgSend {
	"""
	logical operator for BankMsgSend that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterBankMsgSend]
	"""
	logical operator for BankMsgSend that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterBankMsgSend]
	"""
	logical operator for BankMsgSend that will reverse conditions.
	"""
	_not: NestedFilterBankMsgSend
	"""
	filter for from_address field.
	"""
	from_address: FilterString
	"""
	filter for to_address field.
	"""
	to_address: FilterString
	"""
	filter for amount field.
	"""
	amount: FilterString
}
"""
filter for BlockTransaction objects
"""
input NestedFilterBlockTransaction {
	"""
	logical operator for BlockTransaction that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterBlockTransaction]
	"""
	logical operator for BlockTransaction that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterBlockTransaction]
	"""
	logical operator for BlockTransaction that will reverse conditions.
	"""
	_not: NestedFilterBlockTransaction
	"""
	filter for hash field.
	"""
	hash: FilterString
	"""
	filter for fee field.
	"""
	fee: NestedFilterTxFee
	"""
	filter for memo field.
	"""
	memo: FilterString
}
"""
filter for Coin objects
"""
input NestedFilterCoin {
	"""
	logical operator for Coin that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterCoin]
	"""
	logical operator for Coin that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterCoin]
	"""
	logical operator for Coin that will reverse conditions.
	"""
	_not: NestedFilterCoin
	"""
	filter for amount field.
	"""
	amount: FilterInt
	"""
	filter for denom field.
	"""
	denom: FilterString
}
"""
filter for Event objects
"""
input NestedFilterEvent {
	"""
	logical operator for Event that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterEvent]
	"""
	logical operator for Event that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterEvent]
	"""
	logical operator for Event that will reverse conditions.
	"""
	_not: NestedFilterEvent
	"""
	filter for GnoEvent union type.
	"""
	GnoEvent: NestedFilterGnoEvent
	"""
	filter for UnknownEvent union type.
	"""
	UnknownEvent: NestedFilterUnknownEvent
}
"""
filter for GnoEvent objects
"""
input NestedFilterGnoEvent {
	"""
	logical operator for GnoEvent that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterGnoEvent]
	"""
	logical operator for GnoEvent that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterGnoEvent]
	"""
	logical operator for GnoEvent that will reverse conditions.
	"""
	_not: NestedFilterGnoEvent
	"""
	filter for type field.
	"""
	type: FilterString
	"""
	filter for pkg_path field.
	"""
	pkg_path: FilterString
	"""
	filter for func field.
	"""
	func: FilterString
	"""
	filter for attrs field.
	"""
	attrs: NestedFilterGnoEventAttribute
}
"""
filter for GnoEventAttribute objects
"""
input NestedFilterGnoEventAttribute {
	"""
	logical operator for GnoEventAttribute that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterGnoEventAttribute]
	"""
	logical operator for GnoEventAttribute that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterGnoEventAttribute]
	"""
	logical operator for GnoEventAttribute that will reverse conditions.
	"""
	_not: NestedFilterGnoEventAttribute
	"""
	filter for key field.
	"""
	key: FilterString
	"""
	filter for value field.
	"""
	value: FilterString
}
"""
filter for MemFile objects
"""
input NestedFilterMemFile {
	"""
	logical operator for MemFile that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterMemFile]
	"""
	logical operator for MemFile that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterMemFile]
	"""
	logical operator for MemFile that will reverse conditions.
	"""
	_not: NestedFilterMemFile
	"""
	filter for name field.
	"""
	name: FilterString
	"""
	filter for body field.
	"""
	body: FilterString
}
"""
filter for MemPackage objects
"""
input NestedFilterMemPackage {
	"""
	logical operator for MemPackage that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterMemPackage]
	"""
	logical operator for MemPackage that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterMemPackage]
	"""
	logical operator for MemPackage that will reverse conditions.
	"""
	_not: NestedFilterMemPackage
	"""
	filter for name field.
	"""
	name: FilterString
	"""
	filter for path field.
	"""
	path: FilterString
	"""
	filter for files field.
	"""
	files: NestedFilterMemFile
}
"""
filter for MessageValue objects
"""
input NestedFilterMessageValue {
	"""
	logical operator for MessageValue that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterMessageValue]
	"""
	logical operator for MessageValue that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterMessageValue]
	"""
	logical operator for MessageValue that will reverse conditions.
	"""
	_not: NestedFilterMessageValue
	"""
	filter for BankMsgSend union type.
	"""
	BankMsgSend: NestedFilterBankMsgSend
	"""
	filter for MsgCall union type.
	"""
	MsgCall: NestedFilterMsgCall
	"""
	filter for MsgAddPackage union type.
	"""
	MsgAddPackage: NestedFilterMsgAddPackage
	"""
	filter for MsgRun union type.
	"""
	MsgRun: NestedFilterMsgRun
}
"""
filter for MsgAddPackage objects
"""
input NestedFilterMsgAddPackage {
	"""
	logical operator for MsgAddPackage that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterMsgAddPackage]
	"""
	logical operator for MsgAddPackage that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterMsgAddPackage]
	"""
	logical operator for MsgAddPackage that will reverse conditions.
	"""
	_not: NestedFilterMsgAddPackage
	"""
	filter for creator field.
	"""
	creator: FilterString
	"""
	filter for package field.
	"""
	package: NestedFilterMemPackage
	"""
	filter for deposit field.
	"""
	deposit: FilterString
	"""
	filter for send field.
	"""
	send: FilterString
	"""
	filter for max_deposit field.
	"""
	max_deposit: FilterString
}
"""
filter for MsgCall objects
"""
input NestedFilterMsgCall {
	"""
	logical operator for MsgCall that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterMsgCall]
	"""
	logical operator for MsgCall that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterMsgCall]
	"""
	logical operator for MsgCall that will reverse conditions.
	"""
	_not: NestedFilterMsgCall
	"""
	filter for caller field.
	"""
	caller: FilterString
	"""
	filter for send field.
	"""
	send: FilterString
	"""
	filter for pkg_path field.
	"""
	pkg_path: FilterString
	"""
	filter for func field.
	"""
	func: FilterString
	"""
	filter for args field.
	"""
	args: FilterString
	"""
	filter for max_deposit field.
	"""
	max_deposit: FilterString
}
"""
filter for MsgRun objects
"""
input NestedFilterMsgRun {
	"""
	logical operator for MsgRun that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterMsgRun]
	"""
	logical operator for MsgRun that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterMsgRun]
	"""
	logical operator for MsgRun that will reverse conditions.
	"""
	_not: NestedFilterMsgRun
	"""
	filter for caller field.
	"""
	caller: FilterString
	"""
	filter for send field.
	"""
	send: FilterString
	"""
	filter for package field.
	"""
	package: NestedFilterMemPackage
	"""
	filter for max_deposit field.
	"""
	max_deposit: FilterString
}
"""
filter for TransactionMessage objects
"""
input NestedFilterTransactionMessage {
	"""
	logical operator for TransactionMessage that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterTransactionMessage]
	"""
	logical operator for TransactionMessage that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterTransactionMessage]
	"""
	logical operator for TransactionMessage that will reverse conditions.
	"""
	_not: NestedFilterTransactionMessage
	"""
	filter for typeUrl field.
	"""
	typeUrl: FilterString
	"""
	filter for route field.
	"""
	route: FilterString
	"""
	filter for value field.
	"""
	value: NestedFilterMessageValue
}
"""
filter for TransactionResponse objects
"""
input NestedFilterTransactionResponse {
	"""
	logical operator for TransactionResponse that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterTransactionResponse]
	"""
	logical operator for TransactionResponse that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterTransactionResponse]
	"""
	logical operator for TransactionResponse that will reverse conditions.
	"""
	_not: NestedFilterTransactionResponse
	"""
	filter for log field.
	"""
	log: FilterString
	"""
	filter for info field.
	"""
	info: FilterString
	"""
	filter for error field.
	"""
	error: FilterString
	"""
	filter for data field.
	"""
	data: FilterString
	"""
	filter for events field.
	"""
	events: NestedFilterEvent
}
"""
filter for TxFee objects
"""
input NestedFilterTxFee {
	"""
	logical operator for TxFee that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterTxFee]
	"""
	logical operator for TxFee that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterTxFee]
	"""
	logical operator for TxFee that will reverse conditions.
	"""
	_not: NestedFilterTxFee
	"""
	filter for gas_wanted field.
	"""
	gas_wanted: FilterInt
	"""
	filter for gas_fee field.
	"""
	gas_fee: NestedFilterCoin
}
"""
filter for UnknownEvent objects
"""
input NestedFilterUnknownEvent {
	"""
	logical operator for UnknownEvent that will combine two or more conditions, returning true if all of them are true.
	"""
	_and: [NestedFilterUnknownEvent]
	"""
	logical operator for UnknownEvent that will combine two or more conditions, returning true if at least one of them is true.
	"""
	_or: [NestedFilterUnknownEvent]
	"""
	logical operator for UnknownEvent that will reverse conditions.
	"""
	_not: NestedFilterUnknownEvent
	"""
	filter for value field.
	"""
	value: FilterString
}
"""
Order defines the output order for hte method, It can be in DESC (descending) or ASC (ascending) order.
"""
enum Order {
	ASC
	DESC
}
"""
Root Query type to fetch data about Blocks and Transactions based on filters or retrieve the latest block height.
"""
type Query {
	"""
	Retrieves a list of Transactions that match the given filter criteria. If the result is incomplete due to errors, both partial results and errors are returned.
	"""
	transactions(filter: TransactionFilter!): [Transaction!] @deprecated(reason: "Use ` + "`" + `getTransactions` + "`" + ` instead.")
	"""
	Fetches Blocks matching the specified filter criteria. Incomplete results due to errors return both the partial Blocks and the associated errors.
	"""
	blocks(filter: BlockFilter!): [Block!] @deprecated(reason: "Use ` + "`" + `getBlocks` + "`" + ` instead.")
	"""
	Returns the height of the most recently processed Block by the blockchain indexer, indicating the current length of the blockchain.
	"""
	latestBlockHeight: Int!
	"""
	Fetches Blocks matching the specified where criteria. 
	Incomplete results due to errors return both the partial Blocks and 
	the associated errors.
	"""
	getBlocks(where: FilterBlock!, order: BlockOrder): [Block!]
	"""
	Retrieves a list of Transactions that match the given 
	where criteria. If the result is incomplete due to errors, both partial
	results and errors are returned.
	"""
	getTransactions(where: FilterTransaction!, order: TransactionOrder): [Transaction!]
}
"""
Subscriptions provide a way for clients to receive real-time updates about Transactions and Blocks based on specified filter criteria.
Subscribers will only receive updates for events occurring after the subscription is established.
"""
type Subscription {
	"""
	Subscribes to real-time updates of Transactions that match the provided filter criteria.
	This subscription starts immediately and only includes Transactions added to the blockchain after the subscription is active.
	
	This is useful for applications needing to track Transactions in real-time, such as wallets tracking incoming transactions
	or analytics platforms monitoring blockchain activity.
	
	Returns:
	- Transaction: Each received update is a Transaction object that matches the filter criteria.
	"""
	transactions(filter: TransactionFilter!): Transaction! @deprecated(reason: "Use ` + "`" + `getBlocks` + "`" + ` instead.")
	"""
	Subscribes to real-time updates of Blocks that match the provided filter criteria. Similar to the Transactions subscription,
	this subscription is active immediately upon creation and only includes Blocks added after the subscription begins.
	
	This subscription is ideal for services that need to be notified of new Blocks for processing or analysis, such as block explorers,
	data aggregators, or security monitoring tools.
	
	Returns:
	- Block: Each update consists of a Block object that satisfies the filter criteria, allowing subscribers to process or analyze new Blocks in real time.
	"""
	blocks(filter: BlockFilter!): Block! @deprecated(reason: "Use ` + "`" + `getBlocks` + "`" + ` instead.")
	"""
	Subscribes to real-time updates of Transactions that 
	match the provided filter criteria. This subscription starts immediately
	and only includes Transactions added to the blockchain after the subscription
	is active.
	
	This is useful for applications needing to track Transactions in real-time, 
	such as wallets tracking incoming transactions or analytics platforms 
	monitoring blockchain activity.
	
	Returns:
	- Transaction: Each received update is a Transaction object that matches 
	the where criteria.
	"""
	getTransactions(where: FilterTransaction!): Transaction!
	"""
	Subscribes to real-time updates of Blocks that match the provided
	filter criteria. Similar to the Transactions subscription,
	this subscription is active immediately upon creation and only includes Blocks
	added after the subscription begins.
	
	This subscription is ideal for services that need to be notified of new Blocks
	for processing or analysis, such as block explorers, data aggregators, or security
	monitoring tools.
	
	Returns:
	- Block: Each update consists of a Block object that satisfies the filter criteria,
	allowing subscribers to process or analyze new Blocks in real time.
	"""
	getBlocks(where: FilterBlock!): Block!
}
"""
Field representing a point on time. It is following the RFC3339Nano format ("2006-01-02T15:04:05.999999999Z07:00")
"""
scalar Time
"""
Defines a transaction within a block, detailing its execution specifics and content.
"""
type Transaction {
	"""
	A sequential index representing the order of this Transaction within its Block. Unique within the context of its Block.
	"""
	index: Int! @filterable(extras: [MINMAX])
	"""
	Hash from Transaction content in base64 encoding.
	"""
	hash: String! @filterable
	"""
	The success can determine whether the transaction succeeded or failed.
	"""
	success: Boolean! @filterable
	"""
	The height of the Block in which this Transaction is included. Links the Transaction to its containing Block.
	"""
	block_height: Int! @filterable(extras: [MINMAX])
	"""
	The declared amount of computational effort the sender is willing to pay for executing this Transaction.
	"""
	gas_wanted: Int! @filterable
	"""
	The actual amount of computational effort consumed to execute this Transaction. It could be less or equal to ` + "`" + `gas_wanted` + "`" + `.
	"""
	gas_used: Int! @filterable
	"""
	Fee includes the amount of coins paid in fees and the maximum
	gas to be used by the transaction.
	"""
	gas_fee: Coin @filterable
	"""
	The payload of the Transaction in a raw format, typically containing the instructions and any data necessary for execution.
	"""
	content_raw: String!
	"""
	The payload of a message shows the contents of the messages in a transaction.
	A message consists of ` + "`" + `router` + "`" + `, ` + "`" + `type` + "`" + `, and ` + "`" + `value` + "`" + ` (whose form depends on the ` + "`" + `router` + "`" + ` and ` + "`" + `type` + "`" + `).
	"""
	messages: [TransactionMessage]! @filterable
	"""
	` + "`" + `memo` + "`" + ` are string information stored within a transaction.
	` + "`" + `memo` + "`" + ` can be utilized to find or distinguish transactions.
	For example, when trading a specific exchange, you would utilize the memo field of the transaction.
	"""
	memo: String! @filterable
	"""
	` + "`" + `response` + "`" + ` is the processing result of the transaction.
	It has ` + "`" + `log` + "`" + `, ` + "`" + `info` + "`" + `, ` + "`" + `error` + "`" + `, and ` + "`" + `data` + "`" + `.
	"""
	response: TransactionResponse! @filterable
}
"""
` + "`" + `TransactionBankMessageInput` + "`" + ` represents input parameters required when the message router is ` + "`" + `bank` + "`" + `.
"""
input TransactionBankMessageInput {
	"""
	send represents input parameters required when the message type is ` + "`" + `send` + "`" + `.
	"""
	send: BankMsgSendInput
}
"""
Filters for querying Transactions within specified criteria related to their execution and placement within Blocks.
"""
input TransactionFilter {
	"""
	Minimum block height from which to start fetching Transactions, inclusive. Aids in scoping the search to recent Transactions.
	"""
	from_block_height: Int
	"""
	Maximum block height up to which Transactions should be fetched, exclusive. Helps in limiting the search to older Transactions.
	"""
	to_block_height: Int
	"""
	Minimum Transaction index from which to start fetching, inclusive. Facilitates ordering in Transaction queries.
	"""
	from_index: Int
	"""
	Maximum Transaction index up to which to fetch, exclusive. Ensures a limit on the ordering range for Transaction queries.
	"""
	to_index: Int
	"""
	Minimum ` + "`" + `gas_wanted` + "`" + ` value to filter Transactions by, inclusive. Filters Transactions based on the minimum computational effort declared.
	"""
	from_gas_wanted: Int
	"""
	Maximum ` + "`" + `gas_wanted` + "`" + ` value for filtering Transactions, exclusive. Limits Transactions based on the declared computational effort.
	"""
	to_gas_wanted: Int
	"""
	Minimum ` + "`" + `gas_used` + "`" + ` value to filter Transactions by, inclusive. Selects Transactions based on the minimum computational effort actually used.
	"""
	from_gas_used: Int
	"""
	Maximum ` + "`" + `gas_used` + "`" + ` value for filtering Transactions, exclusive. Refines selection based on the computational effort actually consumed.
	"""
	to_gas_used: Int
	"""
	Hash from Transaction content in base64 encoding. If this filter is used, any other filter will be ignored.
	"""
	hash: String
	"""
	Transaction's messages to filter Transactions.
	` + "`" + `message` + "`" + ` can be configured as a filter with a transaction message's ` + "`" + `router` + "`" + ` and ` + "`" + `type` + "`" + ` and ` + "`" + `parameters(bank / vm)` + "`" + `.
	` + "`" + `message` + "`" + ` is entered as an array and works exclusively.
	ex) ` + "`" + `message[0] || message[1] || message[2]` + "`" + `
	"""
	message: [TransactionMessageInput!]
	"""
	` + "`" + `memo` + "`" + ` are string information stored within a transaction.
	` + "`" + `memo` + "`" + ` can be utilized to find or distinguish transactions.
	For example, when trading a specific exchange, you would utilize the memo field of the transaction.
	"""
	memo: String
	"""
	` + "`" + `success` + "`" + ` is whether the transaction was successful or not.
	` + "`" + `success` + "`" + ` enables you to filter between successful and unsuccessful transactions.
	"""
	success: Boolean
	"""
	` + "`" + `events` + "`" + ` are what the transaction has emitted.
	` + "`" + `events` + "`" + ` can be filtered with a specific event to query its transactions.
	` + "`" + `events` + "`" + ` is entered as an array and works exclusively.
	ex) ` + "`" + `events[0] || events[1] || events[2]` + "`" + `
	"""
	events: [EventInput!]
}
type TransactionMessage {
	"""
	The type of transaction message.
	The value of ` + "`" + `typeUrl` + "`" + ` can be ` + "`" + `send` + "`" + `, ` + "`" + `exec` + "`" + `, ` + "`" + `add_package` + "`" + `, ` + "`" + `run` + "`" + `.
	"""
	typeUrl: String! @filterable
	"""
	The route of transaction message.
	The value of ` + "`" + `route` + "`" + ` can be ` + "`" + `bank` + "`" + `, ` + "`" + `vm` + "`" + `.
	"""
	route: String! @filterable
	"""
	MessageValue is the content of the transaction.
	` + "`" + `value` + "`" + ` can be of type ` + "`" + `BankMsgSend` + "`" + `, ` + "`" + `MsgCall` + "`" + `, ` + "`" + `MsgAddPackage` + "`" + `, ` + "`" + `MsgRun` + "`" + `, ` + "`" + `UnexpectedMessage` + "`" + `.
	"""
	value: MessageValue! @filterable
}
"""
Transaction's message to filter Transactions.
` + "`" + `TransactionMessageInput` + "`" + ` can be configured as a filter with a transaction message's ` + "`" + `router` + "`" + ` and ` + "`" + `type` + "`" + ` and ` + "`" + `parameters(bank / vm)` + "`" + `.
"""
input TransactionMessageInput {
	"""
	The type of transaction message.
	The value of ` + "`" + `typeUrl` + "`" + ` can be ` + "`" + `send` + "`" + `, ` + "`" + `exec` + "`" + `, ` + "`" + `add_package` + "`" + `, ` + "`" + `run` + "`" + `.
	"""
	type_url: MessageType
	"""
	The route of transaction message.
	The value of ` + "`" + `route` + "`" + ` can be ` + "`" + `bank` + "`" + `, ` + "`" + `vm` + "`" + `.
	"""
	route: MessageRoute
	"""
	` + "`" + `TransactionBankMessageInput` + "`" + ` represents input parameters required when the message router is ` + "`" + `bank` + "`" + `.
	"""
	bank_param: TransactionBankMessageInput
	"""
	` + "`" + `TransactionVmMessageInput` + "`" + ` represents input parameters required when the message router is ` + "`" + `vm` + "`" + `.
	"""
	vm_param: TransactionVmMessageInput
}
input TransactionOrder {
	heightAndIndex: Order!
}
"""
` + "`" + `TransactionResponse` + "`" + ` is the processing result of the transaction.
It has ` + "`" + `log` + "`" + `, ` + "`" + `info` + "`" + `, ` + "`" + `error` + "`" + `, and ` + "`" + `data` + "`" + `.
"""
type TransactionResponse {
	"""
	The log value associated with the Transaction execution, if any.
	"""
	log: String! @filterable
	"""
	The Info associated with the Transaction execution, if any.
	"""
	info: String! @filterable
	"""
	The error value associated with the Transaction execution, if any.
	"""
	error: String! @filterable
	"""
	The response data associated with the Transaction execution, if any.
	"""
	data: String! @filterable
	"""
	The emitted events associated with the transaction execution, if any.
	"""
	events: [Event] @filterable
}
"""
` + "`" + `TransactionVmMessageInput` + "`" + ` represents input parameters required when the message router is ` + "`" + `vm` + "`" + `.
"""
input TransactionVmMessageInput {
	"""
	` + "`" + `MsgCallInput` + "`" + ` represents input parameters required when the message type is ` + "`" + `exec` + "`" + `.
	"""
	exec: MsgCallInput
	"""
	` + "`" + `MsgAddPackageInput` + "`" + ` represents input parameters required when the message type is ` + "`" + `add_package` + "`" + `.
	"""
	add_package: MsgAddPackageInput
	"""
	` + "`" + `MsgRunInput` + "`" + ` represents input parameters required when the message type is ` + "`" + `run` + "`" + `.
	"""
	run: MsgRunInput
}
"""
The ` + "`" + `TxFee` + "`" + ` has information about the fee used in the transaction and the maximum gas fee specified by the user.
"""
type TxFee {
	"""
	gas limit
	"""
	gas_wanted: Int! @filterable
	"""
	The gas fee in the transaction.
	"""
	gas_fee: Coin! @filterable
}
"""
` + "`" + `UnexpectedMessage` + "`" + ` is an Undefined Message, which is a message that decoding failed.
"""
type UnexpectedMessage {
	raw: String!
}
"""
` + "`" + `UnknownEvent` + "`" + ` is an unknown event type.
It has ` + "`" + `value` + "`" + `.
"""
type UnknownEvent {
	"""
	` + "`" + `value` + "`" + ` is a raw event string.
	"""
	value: String! @filterable
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_filterable_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.dir_filterable_argsExtras(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["extras"] = arg0
	return args, nil
}
func (ec *executionContext) dir_filterable_argsExtras(
	ctx context.Context,
	rawArgs map[string]interface{},
) ([]model.FilterableExtra, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["extras"]
	if !ok {
		var zeroVal []model.FilterableExtra
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("extras"))
	if tmp, ok := rawArgs["extras"]; ok {
		return ec.unmarshalOFilterableExtra2githubcomgnolangtxindexerservegraphmodelFilterableExtra(ctx, tmp)
	}

	var zeroVal []model.FilterableExtra
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]interface{},
) (string, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["name"]
	if !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_blocks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_blocks_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_blocks_argsFilter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (model.BlockFilter, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["filter"]
	if !ok {
		var zeroVal model.BlockFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNBlockFilter2githubcomgnolangtxindexerservegraphmodelBlockFilter(ctx, tmp)
	}

	var zeroVal model.BlockFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getBlocks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_getBlocks_argsWhere(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["where"] = arg0
	arg1, err := ec.field_Query_getBlocks_argsOrder(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["order"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_getBlocks_argsWhere(
	ctx context.Context,
	rawArgs map[string]interface{},
) (model.FilterBlock, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["where"]
	if !ok {
		var zeroVal model.FilterBlock
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
	if tmp, ok := rawArgs["where"]; ok {
		return ec.unmarshalNFilterBlock2githubcomgnolangtxindexerservegraphmodelFilterBlock(ctx, tmp)
	}

	var zeroVal model.FilterBlock
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getBlocks_argsOrder(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*model.BlockOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["order"]
	if !ok {
		var zeroVal *model.BlockOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
	if tmp, ok := rawArgs["order"]; ok {
		return ec.unmarshalOBlockOrder2githubcomgnolangtxindexerservegraphmodelBlockOrder(ctx, tmp)
	}

	var zeroVal *model.BlockOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getTransactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_getTransactions_argsWhere(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["where"] = arg0
	arg1, err := ec.field_Query_getTransactions_argsOrder(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["order"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_getTransactions_argsWhere(
	ctx context.Context,
	rawArgs map[string]interface{},
) (model.FilterTransaction, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["where"]
	if !ok {
		var zeroVal model.FilterTransaction
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
	if tmp, ok := rawArgs["where"]; ok {
		return ec.unmarshalNFilterTransaction2githubcomgnolangtxindexerservegraphmodelFilterTransaction(ctx, tmp)
	}

	var zeroVal model.FilterTransaction
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getTransactions_argsOrder(
	ctx context.Context,
	rawArgs map[string]interface{},
) (*model.TransactionOrder, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["order"]
	if !ok {
		var zeroVal *model.TransactionOrder
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
	if tmp, ok := rawArgs["order"]; ok {
		return ec.unmarshalOTransactionOrder2githubcomgnolangtxindexerservegraphmodelTransactionOrder(ctx, tmp)
	}

	var zeroVal *model.TransactionOrder
	return zeroVal, nil
}

func (ec *executionContext) field_Query_transactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Query_transactions_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_transactions_argsFilter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (model.TransactionFilter, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["filter"]
	if !ok {
		var zeroVal model.TransactionFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNTransactionFilter2githubcomgnolangtxindexerservegraphmodelTransactionFilter(ctx, tmp)
	}

	var zeroVal model.TransactionFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Subscription_blocks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Subscription_blocks_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	return args, nil
}
func (ec *executionContext) field_Subscription_blocks_argsFilter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (model.BlockFilter, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["filter"]
	if !ok {
		var zeroVal model.BlockFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNBlockFilter2githubcomgnolangtxindexerservegraphmodelBlockFilter(ctx, tmp)
	}

	var zeroVal model.BlockFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Subscription_getBlocks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Subscription_getBlocks_argsWhere(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["where"] = arg0
	return args, nil
}
func (ec *executionContext) field_Subscription_getBlocks_argsWhere(
	ctx context.Context,
	rawArgs map[string]interface{},
) (model.FilterBlock, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["where"]
	if !ok {
		var zeroVal model.FilterBlock
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
	if tmp, ok := rawArgs["where"]; ok {
		return ec.unmarshalNFilterBlock2githubcomgnolangtxindexerservegraphmodelFilterBlock(ctx, tmp)
	}

	var zeroVal model.FilterBlock
	return zeroVal, nil
}

func (ec *executionContext) field_Subscription_getTransactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Subscription_getTransactions_argsWhere(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["where"] = arg0
	return args, nil
}
func (ec *executionContext) field_Subscription_getTransactions_argsWhere(
	ctx context.Context,
	rawArgs map[string]interface{},
) (model.FilterTransaction, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["where"]
	if !ok {
		var zeroVal model.FilterTransaction
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
	if tmp, ok := rawArgs["where"]; ok {
		return ec.unmarshalNFilterTransaction2githubcomgnolangtxindexerservegraphmodelFilterTransaction(ctx, tmp)
	}

	var zeroVal model.FilterTransaction
	return zeroVal, nil
}

func (ec *executionContext) field_Subscription_transactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field_Subscription_transactions_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	return args, nil
}
func (ec *executionContext) field_Subscription_transactions_argsFilter(
	ctx context.Context,
	rawArgs map[string]interface{},
) (model.TransactionFilter, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["filter"]
	if !ok {
		var zeroVal model.TransactionFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNTransactionFilter2githubcomgnolangtxindexerservegraphmodelTransactionFilter(ctx, tmp)
	}

	var zeroVal model.TransactionFilter
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]interface{},
) (bool, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["includeDeprecated"]
	if !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]interface{},
) (bool, error) {
	// We won't call the directive if the argument is null.
	// Set call_argument_directives_with_null to true to call directives
	// even if the argument is null.
	_, ok := rawArgs["includeDeprecated"]
	if !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _BankMsgSend_from_address(ctx context.Context, field graphql.CollectedField, obj *model.BankMsgSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BankMsgSend_from_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.FromAddress, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BankMsgSend_from_address(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BankMsgSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BankMsgSend_to_address(ctx context.Context, field graphql.CollectedField, obj *model.BankMsgSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BankMsgSend_to_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ToAddress, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BankMsgSend_to_address(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BankMsgSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BankMsgSend_amount(ctx context.Context, field graphql.CollectedField, obj *model.BankMsgSend) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BankMsgSend_amount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Amount, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BankMsgSend_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BankMsgSend",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_hash(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Hash(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_height(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Height(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			extras, err := ec.unmarshalOFilterableExtra2githubcomgnolangtxindexerservegraphmodelFilterableExtra(ctx, []interface{}{"MINMAX"})
			if err != nil {
				var zeroVal int64
				return zeroVal, err
			}
			if ec.directives.Filterable == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, extras)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_version(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Version(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_chain_id(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_chain_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ChainID(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_chain_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_time(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Time(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal time.Time
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(time.Time); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be time.Time`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_num_txs(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_num_txs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.NumTxs(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_num_txs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_total_txs(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_total_txs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TotalTxs(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_total_txs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_app_version(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_app_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AppVersion(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_app_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_last_block_hash(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_last_block_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LastBlockHash(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_last_block_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_last_commit_hash(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_last_commit_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LastCommitHash(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_last_commit_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_validators_hash(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_validators_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ValidatorsHash(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_validators_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_next_validators_hash(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_next_validators_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.NextValidatorsHash(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_next_validators_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_consensus_hash(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_consensus_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ConsensusHash(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_consensus_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_app_hash(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_app_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AppHash(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_app_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_last_results_hash(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_last_results_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.LastResultsHash(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_last_results_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_proposer_address_raw(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_proposer_address_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ProposerAddressRaw(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_proposer_address_raw(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_txs(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_txs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Txs(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal []*model.BlockTransaction
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.BlockTransaction); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gnolang/tx-indexer/serve/graph/model.BlockTransaction`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.BlockTransaction)
	fc.Result = res
	return ec.marshalNBlockTransaction2githubcomgnolangtxindexerservegraphmodelBlockTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_txs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_BlockTransaction_hash(ctx, field)
			case "fee":
				return ec.fieldContext_BlockTransaction_fee(ctx, field)
			case "memo":
				return ec.fieldContext_BlockTransaction_memo(ctx, field)
			case "content_raw":
				return ec.fieldContext_BlockTransaction_content_raw(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlockTransaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockTransaction_hash(ctx context.Context, field graphql.CollectedField, obj *model.BlockTransaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockTransaction_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Hash, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockTransaction_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockTransaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockTransaction_fee(ctx context.Context, field graphql.CollectedField, obj *model.BlockTransaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockTransaction_fee(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Fee, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal *model.TxFee
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.TxFee); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gnolang/tx-indexer/serve/graph/model.TxFee`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TxFee)
	fc.Result = res
	return ec.marshalNTxFee2githubcomgnolangtxindexerservegraphmodelTxFee(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockTransaction_fee(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockTransaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "gas_wanted":
				return ec.fieldContext_TxFee_gas_wanted(ctx, field)
			case "gas_fee":
				return ec.fieldContext_TxFee_gas_fee(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TxFee", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockTransaction_memo(ctx context.Context, field graphql.CollectedField, obj *model.BlockTransaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockTransaction_memo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Memo, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockTransaction_memo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockTransaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockTransaction_content_raw(ctx context.Context, field graphql.CollectedField, obj *model.BlockTransaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BlockTransaction_content_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRaw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BlockTransaction_content_raw(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockTransaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Coin_amount(ctx context.Context, field graphql.CollectedField, obj *model.Coin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Coin_amount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Amount, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal int
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Coin_amount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Coin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Coin_denom(ctx context.Context, field graphql.CollectedField, obj *model.Coin) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Coin_denom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Denom, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Coin_denom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Coin",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GnoEvent_type(ctx context.Context, field graphql.CollectedField, obj *model.GnoEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GnoEvent_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Type, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GnoEvent_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GnoEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GnoEvent_pkg_path(ctx context.Context, field graphql.CollectedField, obj *model.GnoEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GnoEvent_pkg_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PkgPath, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GnoEvent_pkg_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GnoEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GnoEvent_func(ctx context.Context, field graphql.CollectedField, obj *model.GnoEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GnoEvent_func(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Func, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GnoEvent_func(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GnoEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GnoEvent_attrs(ctx context.Context, field graphql.CollectedField, obj *model.GnoEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GnoEvent_attrs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Attrs, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal []*model.GnoEventAttribute
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.GnoEventAttribute); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gnolang/tx-indexer/serve/graph/model.GnoEventAttribute`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GnoEventAttribute)
	fc.Result = res
	return ec.marshalOGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelGnoEventAttribute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GnoEvent_attrs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GnoEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_GnoEventAttribute_key(ctx, field)
			case "value":
				return ec.fieldContext_GnoEventAttribute_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GnoEventAttribute", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GnoEventAttribute_key(ctx context.Context, field graphql.CollectedField, obj *model.GnoEventAttribute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GnoEventAttribute_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Key, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GnoEventAttribute_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GnoEventAttribute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GnoEventAttribute_value(ctx context.Context, field graphql.CollectedField, obj *model.GnoEventAttribute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GnoEventAttribute_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Value, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GnoEventAttribute_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GnoEventAttribute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MemFile_name(ctx context.Context, field graphql.CollectedField, obj *model.MemFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MemFile_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MemFile_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MemFile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MemFile_body(ctx context.Context, field graphql.CollectedField, obj *model.MemFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MemFile_body(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Body, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MemFile_body(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MemFile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MemPackage_name(ctx context.Context, field graphql.CollectedField, obj *model.MemPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MemPackage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Name, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MemPackage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MemPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MemPackage_path(ctx context.Context, field graphql.CollectedField, obj *model.MemPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MemPackage_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Path, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MemPackage_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MemPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MemPackage_files(ctx context.Context, field graphql.CollectedField, obj *model.MemPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MemPackage_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Files, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal []*model.MemFile
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.MemFile); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gnolang/tx-indexer/serve/graph/model.MemFile`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MemFile)
	fc.Result = res
	return ec.marshalOMemFile2githubcomgnolangtxindexerservegraphmodelMemFile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MemPackage_files(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MemPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_MemFile_name(ctx, field)
			case "body":
				return ec.fieldContext_MemFile_body(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MemFile", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgAddPackage_creator(ctx context.Context, field graphql.CollectedField, obj *model.MsgAddPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgAddPackage_creator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Creator, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgAddPackage_creator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgAddPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgAddPackage_package(ctx context.Context, field graphql.CollectedField, obj *model.MsgAddPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgAddPackage_package(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Package, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal *model.MemPackage
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MemPackage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gnolang/tx-indexer/serve/graph/model.MemPackage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MemPackage)
	fc.Result = res
	return ec.marshalNMemPackage2githubcomgnolangtxindexerservegraphmodelMemPackage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgAddPackage_package(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgAddPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_MemPackage_name(ctx, field)
			case "path":
				return ec.fieldContext_MemPackage_path(ctx, field)
			case "files":
				return ec.fieldContext_MemPackage_files(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MemPackage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgAddPackage_deposit(ctx context.Context, field graphql.CollectedField, obj *model.MsgAddPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgAddPackage_deposit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Deposit, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgAddPackage_deposit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgAddPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgAddPackage_send(ctx context.Context, field graphql.CollectedField, obj *model.MsgAddPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgAddPackage_send(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Send, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgAddPackage_send(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgAddPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgAddPackage_max_deposit(ctx context.Context, field graphql.CollectedField, obj *model.MsgAddPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgAddPackage_max_deposit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MaxDeposit, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgAddPackage_max_deposit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgAddPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgCall_caller(ctx context.Context, field graphql.CollectedField, obj *model.MsgCall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgCall_caller(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Caller, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgCall_caller(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgCall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgCall_send(ctx context.Context, field graphql.CollectedField, obj *model.MsgCall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgCall_send(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Send, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgCall_send(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgCall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgCall_pkg_path(ctx context.Context, field graphql.CollectedField, obj *model.MsgCall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgCall_pkg_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PkgPath, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgCall_pkg_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgCall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgCall_func(ctx context.Context, field graphql.CollectedField, obj *model.MsgCall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgCall_func(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Func, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgCall_func(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgCall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgCall_args(ctx context.Context, field graphql.CollectedField, obj *model.MsgCall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgCall_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Args, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal []string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgCall_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgCall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgCall_max_deposit(ctx context.Context, field graphql.CollectedField, obj *model.MsgCall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgCall_max_deposit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MaxDeposit, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgCall_max_deposit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgCall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgRun_caller(ctx context.Context, field graphql.CollectedField, obj *model.MsgRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgRun_caller(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Caller, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgRun_caller(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgRun_send(ctx context.Context, field graphql.CollectedField, obj *model.MsgRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgRun_send(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Send, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgRun_send(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgRun_package(ctx context.Context, field graphql.CollectedField, obj *model.MsgRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgRun_package(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Package, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal *model.MemPackage
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.MemPackage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gnolang/tx-indexer/serve/graph/model.MemPackage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MemPackage)
	fc.Result = res
	return ec.marshalNMemPackage2githubcomgnolangtxindexerservegraphmodelMemPackage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgRun_package(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_MemPackage_name(ctx, field)
			case "path":
				return ec.fieldContext_MemPackage_path(ctx, field)
			case "files":
				return ec.fieldContext_MemPackage_files(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MemPackage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MsgRun_max_deposit(ctx context.Context, field graphql.CollectedField, obj *model.MsgRun) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MsgRun_max_deposit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.MaxDeposit, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MsgRun_max_deposit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MsgRun",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_transactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_transactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Transactions(rctx, fc.Args["filter"].(model.TransactionFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Transaction)
	fc.Result = res
	return ec.marshalOTransaction2githubcomgnolangtxindexerservegraphmodelTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_transactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "index":
				return ec.fieldContext_Transaction_index(ctx, field)
			case "hash":
				return ec.fieldContext_Transaction_hash(ctx, field)
			case "success":
				return ec.fieldContext_Transaction_success(ctx, field)
			case "block_height":
				return ec.fieldContext_Transaction_block_height(ctx, field)
			case "gas_wanted":
				return ec.fieldContext_Transaction_gas_wanted(ctx, field)
			case "gas_used":
				return ec.fieldContext_Transaction_gas_used(ctx, field)
			case "gas_fee":
				return ec.fieldContext_Transaction_gas_fee(ctx, field)
			case "content_raw":
				return ec.fieldContext_Transaction_content_raw(ctx, field)
			case "messages":
				return ec.fieldContext_Transaction_messages(ctx, field)
			case "memo":
				return ec.fieldContext_Transaction_memo(ctx, field)
			case "response":
				return ec.fieldContext_Transaction_response(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_transactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_blocks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_blocks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Blocks(rctx, fc.Args["filter"].(model.BlockFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Block)
	fc.Result = res
	return ec.marshalOBlock2githubcomgnolangtxindexerservegraphmodelBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_blocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Block_hash(ctx, field)
			case "height":
				return ec.fieldContext_Block_height(ctx, field)
			case "version":
				return ec.fieldContext_Block_version(ctx, field)
			case "chain_id":
				return ec.fieldContext_Block_chain_id(ctx, field)
			case "time":
				return ec.fieldContext_Block_time(ctx, field)
			case "num_txs":
				return ec.fieldContext_Block_num_txs(ctx, field)
			case "total_txs":
				return ec.fieldContext_Block_total_txs(ctx, field)
			case "app_version":
				return ec.fieldContext_Block_app_version(ctx, field)
			case "last_block_hash":
				return ec.fieldContext_Block_last_block_hash(ctx, field)
			case "last_commit_hash":
				return ec.fieldContext_Block_last_commit_hash(ctx, field)
			case "validators_hash":
				return ec.fieldContext_Block_validators_hash(ctx, field)
			case "next_validators_hash":
				return ec.fieldContext_Block_next_validators_hash(ctx, field)
			case "consensus_hash":
				return ec.fieldContext_Block_consensus_hash(ctx, field)
			case "app_hash":
				return ec.fieldContext_Block_app_hash(ctx, field)
			case "last_results_hash":
				return ec.fieldContext_Block_last_results_hash(ctx, field)
			case "proposer_address_raw":
				return ec.fieldContext_Block_proposer_address_raw(ctx, field)
			case "txs":
				return ec.fieldContext_Block_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_blocks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_latestBlockHeight(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_latestBlockHeight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LatestBlockHeight(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_latestBlockHeight(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getBlocks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getBlocks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetBlocks(rctx, fc.Args["where"].(model.FilterBlock), fc.Args["order"].(*model.BlockOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Block)
	fc.Result = res
	return ec.marshalOBlock2githubcomgnolangtxindexerservegraphmodelBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getBlocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Block_hash(ctx, field)
			case "height":
				return ec.fieldContext_Block_height(ctx, field)
			case "version":
				return ec.fieldContext_Block_version(ctx, field)
			case "chain_id":
				return ec.fieldContext_Block_chain_id(ctx, field)
			case "time":
				return ec.fieldContext_Block_time(ctx, field)
			case "num_txs":
				return ec.fieldContext_Block_num_txs(ctx, field)
			case "total_txs":
				return ec.fieldContext_Block_total_txs(ctx, field)
			case "app_version":
				return ec.fieldContext_Block_app_version(ctx, field)
			case "last_block_hash":
				return ec.fieldContext_Block_last_block_hash(ctx, field)
			case "last_commit_hash":
				return ec.fieldContext_Block_last_commit_hash(ctx, field)
			case "validators_hash":
				return ec.fieldContext_Block_validators_hash(ctx, field)
			case "next_validators_hash":
				return ec.fieldContext_Block_next_validators_hash(ctx, field)
			case "consensus_hash":
				return ec.fieldContext_Block_consensus_hash(ctx, field)
			case "app_hash":
				return ec.fieldContext_Block_app_hash(ctx, field)
			case "last_results_hash":
				return ec.fieldContext_Block_last_results_hash(ctx, field)
			case "proposer_address_raw":
				return ec.fieldContext_Block_proposer_address_raw(ctx, field)
			case "txs":
				return ec.fieldContext_Block_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getBlocks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getTransactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getTransactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetTransactions(rctx, fc.Args["where"].(model.FilterTransaction), fc.Args["order"].(*model.TransactionOrder))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Transaction)
	fc.Result = res
	return ec.marshalOTransaction2githubcomgnolangtxindexerservegraphmodelTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "index":
				return ec.fieldContext_Transaction_index(ctx, field)
			case "hash":
				return ec.fieldContext_Transaction_hash(ctx, field)
			case "success":
				return ec.fieldContext_Transaction_success(ctx, field)
			case "block_height":
				return ec.fieldContext_Transaction_block_height(ctx, field)
			case "gas_wanted":
				return ec.fieldContext_Transaction_gas_wanted(ctx, field)
			case "gas_used":
				return ec.fieldContext_Transaction_gas_used(ctx, field)
			case "gas_fee":
				return ec.fieldContext_Transaction_gas_fee(ctx, field)
			case "content_raw":
				return ec.fieldContext_Transaction_content_raw(ctx, field)
			case "messages":
				return ec.fieldContext_Transaction_messages(ctx, field)
			case "memo":
				return ec.fieldContext_Transaction_memo(ctx, field)
			case "response":
				return ec.fieldContext_Transaction_response(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getTransactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_transactions(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_transactions(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Transactions(rctx, fc.Args["filter"].(model.TransactionFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Transaction):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNTransaction2githubcomgnolangtxindexerservegraphmodelTransaction(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_transactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "index":
				return ec.fieldContext_Transaction_index(ctx, field)
			case "hash":
				return ec.fieldContext_Transaction_hash(ctx, field)
			case "success":
				return ec.fieldContext_Transaction_success(ctx, field)
			case "block_height":
				return ec.fieldContext_Transaction_block_height(ctx, field)
			case "gas_wanted":
				return ec.fieldContext_Transaction_gas_wanted(ctx, field)
			case "gas_used":
				return ec.fieldContext_Transaction_gas_used(ctx, field)
			case "gas_fee":
				return ec.fieldContext_Transaction_gas_fee(ctx, field)
			case "content_raw":
				return ec.fieldContext_Transaction_content_raw(ctx, field)
			case "messages":
				return ec.fieldContext_Transaction_messages(ctx, field)
			case "memo":
				return ec.fieldContext_Transaction_memo(ctx, field)
			case "response":
				return ec.fieldContext_Transaction_response(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_transactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_blocks(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_blocks(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Blocks(rctx, fc.Args["filter"].(model.BlockFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Block):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNBlock2githubcomgnolangtxindexerservegraphmodelBlock(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_blocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Block_hash(ctx, field)
			case "height":
				return ec.fieldContext_Block_height(ctx, field)
			case "version":
				return ec.fieldContext_Block_version(ctx, field)
			case "chain_id":
				return ec.fieldContext_Block_chain_id(ctx, field)
			case "time":
				return ec.fieldContext_Block_time(ctx, field)
			case "num_txs":
				return ec.fieldContext_Block_num_txs(ctx, field)
			case "total_txs":
				return ec.fieldContext_Block_total_txs(ctx, field)
			case "app_version":
				return ec.fieldContext_Block_app_version(ctx, field)
			case "last_block_hash":
				return ec.fieldContext_Block_last_block_hash(ctx, field)
			case "last_commit_hash":
				return ec.fieldContext_Block_last_commit_hash(ctx, field)
			case "validators_hash":
				return ec.fieldContext_Block_validators_hash(ctx, field)
			case "next_validators_hash":
				return ec.fieldContext_Block_next_validators_hash(ctx, field)
			case "consensus_hash":
				return ec.fieldContext_Block_consensus_hash(ctx, field)
			case "app_hash":
				return ec.fieldContext_Block_app_hash(ctx, field)
			case "last_results_hash":
				return ec.fieldContext_Block_last_results_hash(ctx, field)
			case "proposer_address_raw":
				return ec.fieldContext_Block_proposer_address_raw(ctx, field)
			case "txs":
				return ec.fieldContext_Block_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_blocks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_getTransactions(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_getTransactions(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().GetTransactions(rctx, fc.Args["where"].(model.FilterTransaction))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Transaction):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNTransaction2githubcomgnolangtxindexerservegraphmodelTransaction(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_getTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "index":
				return ec.fieldContext_Transaction_index(ctx, field)
			case "hash":
				return ec.fieldContext_Transaction_hash(ctx, field)
			case "success":
				return ec.fieldContext_Transaction_success(ctx, field)
			case "block_height":
				return ec.fieldContext_Transaction_block_height(ctx, field)
			case "gas_wanted":
				return ec.fieldContext_Transaction_gas_wanted(ctx, field)
			case "gas_used":
				return ec.fieldContext_Transaction_gas_used(ctx, field)
			case "gas_fee":
				return ec.fieldContext_Transaction_gas_fee(ctx, field)
			case "content_raw":
				return ec.fieldContext_Transaction_content_raw(ctx, field)
			case "messages":
				return ec.fieldContext_Transaction_messages(ctx, field)
			case "memo":
				return ec.fieldContext_Transaction_memo(ctx, field)
			case "response":
				return ec.fieldContext_Transaction_response(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Transaction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_getTransactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_getBlocks(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_getBlocks(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().GetBlocks(rctx, fc.Args["where"].(model.FilterBlock))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Block):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNBlock2githubcomgnolangtxindexerservegraphmodelBlock(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_getBlocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Block_hash(ctx, field)
			case "height":
				return ec.fieldContext_Block_height(ctx, field)
			case "version":
				return ec.fieldContext_Block_version(ctx, field)
			case "chain_id":
				return ec.fieldContext_Block_chain_id(ctx, field)
			case "time":
				return ec.fieldContext_Block_time(ctx, field)
			case "num_txs":
				return ec.fieldContext_Block_num_txs(ctx, field)
			case "total_txs":
				return ec.fieldContext_Block_total_txs(ctx, field)
			case "app_version":
				return ec.fieldContext_Block_app_version(ctx, field)
			case "last_block_hash":
				return ec.fieldContext_Block_last_block_hash(ctx, field)
			case "last_commit_hash":
				return ec.fieldContext_Block_last_commit_hash(ctx, field)
			case "validators_hash":
				return ec.fieldContext_Block_validators_hash(ctx, field)
			case "next_validators_hash":
				return ec.fieldContext_Block_next_validators_hash(ctx, field)
			case "consensus_hash":
				return ec.fieldContext_Block_consensus_hash(ctx, field)
			case "app_hash":
				return ec.fieldContext_Block_app_hash(ctx, field)
			case "last_results_hash":
				return ec.fieldContext_Block_last_results_hash(ctx, field)
			case "proposer_address_raw":
				return ec.fieldContext_Block_proposer_address_raw(ctx, field)
			case "txs":
				return ec.fieldContext_Block_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_getBlocks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_index(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Index(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			extras, err := ec.unmarshalOFilterableExtra2githubcomgnolangtxindexerservegraphmodelFilterableExtra(ctx, []interface{}{"MINMAX"})
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.Filterable == nil {
				var zeroVal int
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, extras)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_index(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_hash(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Hash(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_success(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Success(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal bool
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_success(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_block_height(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_block_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.BlockHeight(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			extras, err := ec.unmarshalOFilterableExtra2githubcomgnolangtxindexerservegraphmodelFilterableExtra(ctx, []interface{}{"MINMAX"})
			if err != nil {
				var zeroVal int
				return zeroVal, err
			}
			if ec.directives.Filterable == nil {
				var zeroVal int
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, extras)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_block_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_gas_wanted(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_gas_wanted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GasWanted(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal int
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_gas_wanted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_gas_used(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_gas_used(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GasUsed(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal int
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_gas_used(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_gas_fee(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_gas_fee(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GasFee(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal *model.Coin
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Coin); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gnolang/tx-indexer/serve/graph/model.Coin`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Coin)
	fc.Result = res
	return ec.marshalOCoin2githubcomgnolangtxindexerservegraphmodelCoin(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_gas_fee(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "amount":
				return ec.fieldContext_Coin_amount(ctx, field)
			case "denom":
				return ec.fieldContext_Coin_denom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Coin", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_content_raw(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_content_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContentRaw(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_content_raw(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_messages(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_messages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Messages(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal []*model.TransactionMessage
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.TransactionMessage); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gnolang/tx-indexer/serve/graph/model.TransactionMessage`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TransactionMessage)
	fc.Result = res
	return ec.marshalNTransactionMessage2githubcomgnolangtxindexerservegraphmodelTransactionMessage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_messages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "typeUrl":
				return ec.fieldContext_TransactionMessage_typeUrl(ctx, field)
			case "route":
				return ec.fieldContext_TransactionMessage_route(ctx, field)
			case "value":
				return ec.fieldContext_TransactionMessage_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_memo(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_memo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Memo(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_memo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Transaction_response(ctx context.Context, field graphql.CollectedField, obj *model.Transaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Transaction_response(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Response(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal *model.TransactionResponse
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.TransactionResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gnolang/tx-indexer/serve/graph/model.TransactionResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TransactionResponse)
	fc.Result = res
	return ec.marshalNTransactionResponse2githubcomgnolangtxindexerservegraphmodelTransactionResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Transaction_response(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Transaction",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "log":
				return ec.fieldContext_TransactionResponse_log(ctx, field)
			case "info":
				return ec.fieldContext_TransactionResponse_info(ctx, field)
			case "error":
				return ec.fieldContext_TransactionResponse_error(ctx, field)
			case "data":
				return ec.fieldContext_TransactionResponse_data(ctx, field)
			case "events":
				return ec.fieldContext_TransactionResponse_events(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TransactionResponse", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionMessage_typeUrl(ctx context.Context, field graphql.CollectedField, obj *model.TransactionMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionMessage_typeUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TypeURL, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionMessage_typeUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionMessage_route(ctx context.Context, field graphql.CollectedField, obj *model.TransactionMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionMessage_route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Route, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionMessage_route(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionMessage_value(ctx context.Context, field graphql.CollectedField, obj *model.TransactionMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionMessage_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Value, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal model.MessageValue
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.MessageValue); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/gnolang/tx-indexer/serve/graph/model.MessageValue`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MessageValue)
	fc.Result = res
	return ec.marshalNMessageValue2githubcomgnolangtxindexerservegraphmodelMessageValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionMessage_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MessageValue does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionResponse_log(ctx context.Context, field graphql.CollectedField, obj *model.TransactionResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionResponse_log(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Log(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionResponse_log(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionResponse_info(ctx context.Context, field graphql.CollectedField, obj *model.TransactionResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionResponse_info(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Info(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionResponse_info(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionResponse_error(ctx context.Context, field graphql.CollectedField, obj *model.TransactionResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionResponse_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Error(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionResponse_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionResponse_data(ctx context.Context, field graphql.CollectedField, obj *model.TransactionResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionResponse_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Data(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionResponse_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TransactionResponse_events(ctx context.Context, field graphql.CollectedField, obj *model.TransactionResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TransactionResponse_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Events(), nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal []model.Event
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]model.Event); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/gnolang/tx-indexer/serve/graph/model.Event`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.Event)
	fc.Result = res
	return ec.marshalOEvent2githubcomgnolangtxindexerservegraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TransactionResponse_events(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TransactionResponse",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Event does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxFee_gas_wanted(ctx context.Context, field graphql.CollectedField, obj *model.TxFee) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxFee_gas_wanted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GasWanted, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal int
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxFee_gas_wanted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxFee",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxFee_gas_fee(ctx context.Context, field graphql.CollectedField, obj *model.TxFee) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxFee_gas_fee(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GasFee, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal *model.Coin
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.Coin); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gnolang/tx-indexer/serve/graph/model.Coin`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Coin)
	fc.Result = res
	return ec.marshalNCoin2githubcomgnolangtxindexerservegraphmodelCoin(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxFee_gas_fee(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxFee",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "amount":
				return ec.fieldContext_Coin_amount(ctx, field)
			case "denom":
				return ec.fieldContext_Coin_denom(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Coin", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnexpectedMessage_raw(ctx context.Context, field graphql.CollectedField, obj *model.UnexpectedMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnexpectedMessage_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Raw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnexpectedMessage_raw(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnexpectedMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UnknownEvent_value(ctx context.Context, field graphql.CollectedField, obj *model.UnknownEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UnknownEvent_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Value, nil
		}

		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Filterable == nil {
				var zeroVal string
				return zeroVal, errors.New("directive filterable is not implemented")
			}
			return ec.directives.Filterable(ctx, obj, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UnknownEvent_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UnknownEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAmountInput(ctx context.Context, obj interface{}) (model.AmountInput, error) {
	var it model.AmountInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"from", "to", "denomination"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "from":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.From = data
		case "to":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.To = data
		case "denomination":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("denomination"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Denomination = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBankMsgSendInput(ctx context.Context, obj interface{}) (model.BankMsgSendInput, error) {
	var it model.BankMsgSendInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"from_address", "to_address", "amount"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "from_address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from_address"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromAddress = data
		case "to_address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to_address"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToAddress = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOAmountInput2githubcomgnolangtxindexerservegraphmodelAmountInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBlockFilter(ctx context.Context, obj interface{}) (model.BlockFilter, error) {
	var it model.BlockFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"from_height", "to_height", "from_time", "to_time"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "from_height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from_height"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromHeight = data
		case "to_height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to_height"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToHeight = data
		case "from_time":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from_time"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromTime = data
		case "to_time":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to_time"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToTime = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBlockOrder(ctx context.Context, obj interface{}) (model.BlockOrder, error) {
	var it model.BlockOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"height"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalNOrder2githubcomgnolangtxindexerservegraphmodelOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventAttributeInput(ctx context.Context, obj interface{}) (model.EventAttributeInput, error) {
	var it model.EventAttributeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventInput(ctx context.Context, obj interface{}) (model.EventInput, error) {
	var it model.EventInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "pkg_path", "func", "attrs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "pkg_path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pkg_path"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PkgPath = data
		case "func":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("func"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Func = data
		case "attrs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attrs"))
			data, err := ec.unmarshalOEventAttributeInput2githubcomgnolangtxindexerservegraphmodelEventAttributeInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Attrs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterBankMsgSend(ctx context.Context, obj interface{}) (model.FilterBankMsgSend, error) {
	var it model.FilterBankMsgSend
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "from_address", "to_address", "amount"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelFilterBankMsgSend(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelFilterBankMsgSend(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelFilterBankMsgSend(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "from_address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from_address"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromAddress = data
		case "to_address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to_address"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToAddress = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterBlock(ctx context.Context, obj interface{}) (model.FilterBlock, error) {
	var it model.FilterBlock
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "hash", "height", "version", "chain_id", "time", "num_txs", "total_txs", "app_version", "last_block_hash", "last_commit_hash", "validators_hash", "next_validators_hash", "consensus_hash", "app_hash", "last_results_hash", "proposer_address_raw", "txs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterBlock2githubcomgnolangtxindexerservegraphmodelFilterBlock(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterBlock2githubcomgnolangtxindexerservegraphmodelFilterBlock(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterBlock2githubcomgnolangtxindexerservegraphmodelFilterBlock(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hash = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		case "chain_id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("chain_id"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChainID = data
		case "time":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("time"))
			data, err := ec.unmarshalOFilterTime2githubcomgnolangtxindexerservegraphmodelFilterTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Time = data
		case "num_txs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("num_txs"))
			data, err := ec.unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumTxs = data
		case "total_txs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("total_txs"))
			data, err := ec.unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.TotalTxs = data
		case "app_version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("app_version"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppVersion = data
		case "last_block_hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last_block_hash"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastBlockHash = data
		case "last_commit_hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last_commit_hash"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCommitHash = data
		case "validators_hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validators_hash"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValidatorsHash = data
		case "next_validators_hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("next_validators_hash"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.NextValidatorsHash = data
		case "consensus_hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("consensus_hash"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConsensusHash = data
		case "app_hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("app_hash"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppHash = data
		case "last_results_hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last_results_hash"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastResultsHash = data
		case "proposer_address_raw":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proposer_address_raw"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProposerAddressRaw = data
		case "txs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("txs"))
			data, err := ec.unmarshalONestedFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelNestedFilterBlockTransaction(ctx, v)
			if err != nil {
				return it, err
			}
			it.Txs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterBlockTransaction(ctx context.Context, obj interface{}) (model.FilterBlockTransaction, error) {
	var it model.FilterBlockTransaction
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "hash", "fee", "memo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelFilterBlockTransaction(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelFilterBlockTransaction(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelFilterBlockTransaction(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hash = data
		case "fee":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fee"))
			data, err := ec.unmarshalONestedFilterTxFee2githubcomgnolangtxindexerservegraphmodelNestedFilterTxFee(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fee = data
		case "memo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memo"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Memo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterBoolean(ctx context.Context, obj interface{}) (model.FilterBoolean, error) {
	var it model.FilterBoolean
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"exists", "eq"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "exists":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exists"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Exists = data
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterCoin(ctx context.Context, obj interface{}) (model.FilterCoin, error) {
	var it model.FilterCoin
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "amount", "denom"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterCoin2githubcomgnolangtxindexerservegraphmodelFilterCoin(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterCoin2githubcomgnolangtxindexerservegraphmodelFilterCoin(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterCoin2githubcomgnolangtxindexerservegraphmodelFilterCoin(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		case "denom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("denom"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Denom = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterEvent(ctx context.Context, obj interface{}) (model.FilterEvent, error) {
	var it model.FilterEvent
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "GnoEvent", "UnknownEvent"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterEvent2githubcomgnolangtxindexerservegraphmodelFilterEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterEvent2githubcomgnolangtxindexerservegraphmodelFilterEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterEvent2githubcomgnolangtxindexerservegraphmodelFilterEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "GnoEvent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("GnoEvent"))
			data, err := ec.unmarshalONestedFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.GnoEvent = data
		case "UnknownEvent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("UnknownEvent"))
			data, err := ec.unmarshalONestedFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterUnknownEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnknownEvent = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterGnoEvent(ctx context.Context, obj interface{}) (model.FilterGnoEvent, error) {
	var it model.FilterGnoEvent
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "type", "pkg_path", "func", "attrs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelFilterGnoEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelFilterGnoEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelFilterGnoEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "pkg_path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pkg_path"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.PkgPath = data
		case "func":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("func"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Func = data
		case "attrs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attrs"))
			data, err := ec.unmarshalONestedFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEventAttribute(ctx, v)
			if err != nil {
				return it, err
			}
			it.Attrs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterGnoEventAttribute(ctx context.Context, obj interface{}) (model.FilterGnoEventAttribute, error) {
	var it model.FilterGnoEventAttribute
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelFilterGnoEventAttribute(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelFilterGnoEventAttribute(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelFilterGnoEventAttribute(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterInt(ctx context.Context, obj interface{}) (model.FilterInt, error) {
	var it model.FilterInt
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"exists", "eq", "gt", "lt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "exists":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exists"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Exists = data
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "gt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gt"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gt = data
		case "lt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lt"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lt = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterMemFile(ctx context.Context, obj interface{}) (model.FilterMemFile, error) {
	var it model.FilterMemFile
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "name", "body"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterMemFile2githubcomgnolangtxindexerservegraphmodelFilterMemFile(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterMemFile2githubcomgnolangtxindexerservegraphmodelFilterMemFile(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterMemFile2githubcomgnolangtxindexerservegraphmodelFilterMemFile(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "body":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("body"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Body = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterMemPackage(ctx context.Context, obj interface{}) (model.FilterMemPackage, error) {
	var it model.FilterMemPackage
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "name", "path", "files"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterMemPackage2githubcomgnolangtxindexerservegraphmodelFilterMemPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterMemPackage2githubcomgnolangtxindexerservegraphmodelFilterMemPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterMemPackage2githubcomgnolangtxindexerservegraphmodelFilterMemPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "files":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("files"))
			data, err := ec.unmarshalONestedFilterMemFile2githubcomgnolangtxindexerservegraphmodelNestedFilterMemFile(ctx, v)
			if err != nil {
				return it, err
			}
			it.Files = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterMessageValue(ctx context.Context, obj interface{}) (model.FilterMessageValue, error) {
	var it model.FilterMessageValue
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "BankMsgSend", "MsgCall", "MsgAddPackage", "MsgRun"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterMessageValue2githubcomgnolangtxindexerservegraphmodelFilterMessageValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterMessageValue2githubcomgnolangtxindexerservegraphmodelFilterMessageValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterMessageValue2githubcomgnolangtxindexerservegraphmodelFilterMessageValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "BankMsgSend":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("BankMsgSend"))
			data, err := ec.unmarshalONestedFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelNestedFilterBankMsgSend(ctx, v)
			if err != nil {
				return it, err
			}
			it.BankMsgSend = data
		case "MsgCall":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("MsgCall"))
			data, err := ec.unmarshalONestedFilterMsgCall2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgCall(ctx, v)
			if err != nil {
				return it, err
			}
			it.MsgCall = data
		case "MsgAddPackage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("MsgAddPackage"))
			data, err := ec.unmarshalONestedFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgAddPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.MsgAddPackage = data
		case "MsgRun":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("MsgRun"))
			data, err := ec.unmarshalONestedFilterMsgRun2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgRun(ctx, v)
			if err != nil {
				return it, err
			}
			it.MsgRun = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterMsgAddPackage(ctx context.Context, obj interface{}) (model.FilterMsgAddPackage, error) {
	var it model.FilterMsgAddPackage
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "creator", "package", "deposit", "send", "max_deposit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelFilterMsgAddPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelFilterMsgAddPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelFilterMsgAddPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "creator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creator"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Creator = data
		case "package":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("package"))
			data, err := ec.unmarshalONestedFilterMemPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMemPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Package = data
		case "deposit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deposit"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deposit = data
		case "send":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("send"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Send = data
		case "max_deposit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_deposit"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDeposit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterMsgCall(ctx context.Context, obj interface{}) (model.FilterMsgCall, error) {
	var it model.FilterMsgCall
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "caller", "send", "pkg_path", "func", "args", "max_deposit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterMsgCall2githubcomgnolangtxindexerservegraphmodelFilterMsgCall(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterMsgCall2githubcomgnolangtxindexerservegraphmodelFilterMsgCall(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterMsgCall2githubcomgnolangtxindexerservegraphmodelFilterMsgCall(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "caller":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caller"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caller = data
		case "send":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("send"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Send = data
		case "pkg_path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pkg_path"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.PkgPath = data
		case "func":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("func"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Func = data
		case "args":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("args"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Args = data
		case "max_deposit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_deposit"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDeposit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterMsgRun(ctx context.Context, obj interface{}) (model.FilterMsgRun, error) {
	var it model.FilterMsgRun
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "caller", "send", "package", "max_deposit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterMsgRun2githubcomgnolangtxindexerservegraphmodelFilterMsgRun(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterMsgRun2githubcomgnolangtxindexerservegraphmodelFilterMsgRun(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterMsgRun2githubcomgnolangtxindexerservegraphmodelFilterMsgRun(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "caller":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caller"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caller = data
		case "send":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("send"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Send = data
		case "package":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("package"))
			data, err := ec.unmarshalONestedFilterMemPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMemPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Package = data
		case "max_deposit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_deposit"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDeposit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterString(ctx context.Context, obj interface{}) (model.FilterString, error) {
	var it model.FilterString
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"exists", "eq", "like"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "exists":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exists"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Exists = data
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "like":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("like"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Like = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterTime(ctx context.Context, obj interface{}) (model.FilterTime, error) {
	var it model.FilterTime
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"exists", "eq", "before", "after"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "exists":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exists"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Exists = data
		case "eq":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eq"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Eq = data
		case "before":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "after":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.After = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterTransaction(ctx context.Context, obj interface{}) (model.FilterTransaction, error) {
	var it model.FilterTransaction
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "index", "hash", "success", "block_height", "gas_wanted", "gas_used", "gas_fee", "messages", "memo", "response"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterTransaction2githubcomgnolangtxindexerservegraphmodelFilterTransaction(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterTransaction2githubcomgnolangtxindexerservegraphmodelFilterTransaction(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterTransaction2githubcomgnolangtxindexerservegraphmodelFilterTransaction(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "index":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("index"))
			data, err := ec.unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.Index = data
		case "hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hash = data
		case "success":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("success"))
			data, err := ec.unmarshalOFilterBoolean2githubcomgnolangtxindexerservegraphmodelFilterBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Success = data
		case "block_height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("block_height"))
			data, err := ec.unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockHeight = data
		case "gas_wanted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gas_wanted"))
			data, err := ec.unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.GasWanted = data
		case "gas_used":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gas_used"))
			data, err := ec.unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.GasUsed = data
		case "gas_fee":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gas_fee"))
			data, err := ec.unmarshalONestedFilterCoin2githubcomgnolangtxindexerservegraphmodelNestedFilterCoin(ctx, v)
			if err != nil {
				return it, err
			}
			it.GasFee = data
		case "messages":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("messages"))
			data, err := ec.unmarshalONestedFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionMessage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Messages = data
		case "memo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memo"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Memo = data
		case "response":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("response"))
			data, err := ec.unmarshalONestedFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionResponse(ctx, v)
			if err != nil {
				return it, err
			}
			it.Response = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterTransactionMessage(ctx context.Context, obj interface{}) (model.FilterTransactionMessage, error) {
	var it model.FilterTransactionMessage
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "typeUrl", "route", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelFilterTransactionMessage(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelFilterTransactionMessage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelFilterTransactionMessage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "typeUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeUrl"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeURL = data
		case "route":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Route = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalONestedFilterMessageValue2githubcomgnolangtxindexerservegraphmodelNestedFilterMessageValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterTransactionResponse(ctx context.Context, obj interface{}) (model.FilterTransactionResponse, error) {
	var it model.FilterTransactionResponse
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "log", "info", "error", "data", "events"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelFilterTransactionResponse(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelFilterTransactionResponse(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelFilterTransactionResponse(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "log":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("log"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Log = data
		case "info":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("info"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Info = data
		case "error":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("error"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Error = data
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "events":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("events"))
			data, err := ec.unmarshalONestedFilterEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Events = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterTxFee(ctx context.Context, obj interface{}) (model.FilterTxFee, error) {
	var it model.FilterTxFee
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "gas_wanted", "gas_fee"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterTxFee2githubcomgnolangtxindexerservegraphmodelFilterTxFee(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterTxFee2githubcomgnolangtxindexerservegraphmodelFilterTxFee(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterTxFee2githubcomgnolangtxindexerservegraphmodelFilterTxFee(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "gas_wanted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gas_wanted"))
			data, err := ec.unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.GasWanted = data
		case "gas_fee":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gas_fee"))
			data, err := ec.unmarshalONestedFilterCoin2githubcomgnolangtxindexerservegraphmodelNestedFilterCoin(ctx, v)
			if err != nil {
				return it, err
			}
			it.GasFee = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterUnknownEvent(ctx context.Context, obj interface{}) (model.FilterUnknownEvent, error) {
	var it model.FilterUnknownEvent
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalOFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelFilterUnknownEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalOFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelFilterUnknownEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalOFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelFilterUnknownEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMemFileInput(ctx context.Context, obj interface{}) (model.MemFileInput, error) {
	var it model.MemFileInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "body"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "body":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("body"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Body = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMemPackageInput(ctx context.Context, obj interface{}) (model.MemPackageInput, error) {
	var it model.MemPackageInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "path", "files"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "files":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("files"))
			data, err := ec.unmarshalOMemFileInput2githubcomgnolangtxindexerservegraphmodelMemFileInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Files = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMsgAddPackageInput(ctx context.Context, obj interface{}) (model.MsgAddPackageInput, error) {
	var it model.MsgAddPackageInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"creator", "package", "deposit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "creator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creator"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Creator = data
		case "package":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("package"))
			data, err := ec.unmarshalOMemPackageInput2githubcomgnolangtxindexerservegraphmodelMemPackageInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Package = data
		case "deposit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deposit"))
			data, err := ec.unmarshalOAmountInput2githubcomgnolangtxindexerservegraphmodelAmountInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deposit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMsgCallInput(ctx context.Context, obj interface{}) (model.MsgCallInput, error) {
	var it model.MsgCallInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"caller", "send", "pkg_path", "func", "args"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "caller":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caller"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caller = data
		case "send":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("send"))
			data, err := ec.unmarshalOAmountInput2githubcomgnolangtxindexerservegraphmodelAmountInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Send = data
		case "pkg_path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pkg_path"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PkgPath = data
		case "func":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("func"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Func = data
		case "args":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("args"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Args = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMsgRunInput(ctx context.Context, obj interface{}) (model.MsgRunInput, error) {
	var it model.MsgRunInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"caller", "send", "package"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "caller":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caller"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caller = data
		case "send":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("send"))
			data, err := ec.unmarshalOAmountInput2githubcomgnolangtxindexerservegraphmodelAmountInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Send = data
		case "package":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("package"))
			data, err := ec.unmarshalOMemPackageInput2githubcomgnolangtxindexerservegraphmodelMemPackageInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Package = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterBankMsgSend(ctx context.Context, obj interface{}) (model.NestedFilterBankMsgSend, error) {
	var it model.NestedFilterBankMsgSend
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "from_address", "to_address", "amount"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelNestedFilterBankMsgSend(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelNestedFilterBankMsgSend(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelNestedFilterBankMsgSend(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "from_address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from_address"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromAddress = data
		case "to_address":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to_address"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToAddress = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterBlockTransaction(ctx context.Context, obj interface{}) (model.NestedFilterBlockTransaction, error) {
	var it model.NestedFilterBlockTransaction
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "hash", "fee", "memo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelNestedFilterBlockTransaction(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelNestedFilterBlockTransaction(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelNestedFilterBlockTransaction(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hash = data
		case "fee":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fee"))
			data, err := ec.unmarshalONestedFilterTxFee2githubcomgnolangtxindexerservegraphmodelNestedFilterTxFee(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fee = data
		case "memo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memo"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Memo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterCoin(ctx context.Context, obj interface{}) (model.NestedFilterCoin, error) {
	var it model.NestedFilterCoin
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "amount", "denom"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterCoin2githubcomgnolangtxindexerservegraphmodelNestedFilterCoin(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterCoin2githubcomgnolangtxindexerservegraphmodelNestedFilterCoin(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterCoin2githubcomgnolangtxindexerservegraphmodelNestedFilterCoin(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "amount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			data, err := ec.unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amount = data
		case "denom":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("denom"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Denom = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterEvent(ctx context.Context, obj interface{}) (model.NestedFilterEvent, error) {
	var it model.NestedFilterEvent
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "GnoEvent", "UnknownEvent"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "GnoEvent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("GnoEvent"))
			data, err := ec.unmarshalONestedFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.GnoEvent = data
		case "UnknownEvent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("UnknownEvent"))
			data, err := ec.unmarshalONestedFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterUnknownEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnknownEvent = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterGnoEvent(ctx context.Context, obj interface{}) (model.NestedFilterGnoEvent, error) {
	var it model.NestedFilterGnoEvent
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "type", "pkg_path", "func", "attrs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "pkg_path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pkg_path"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.PkgPath = data
		case "func":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("func"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Func = data
		case "attrs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("attrs"))
			data, err := ec.unmarshalONestedFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEventAttribute(ctx, v)
			if err != nil {
				return it, err
			}
			it.Attrs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterGnoEventAttribute(ctx context.Context, obj interface{}) (model.NestedFilterGnoEventAttribute, error) {
	var it model.NestedFilterGnoEventAttribute
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEventAttribute(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEventAttribute(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEventAttribute(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterMemFile(ctx context.Context, obj interface{}) (model.NestedFilterMemFile, error) {
	var it model.NestedFilterMemFile
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "name", "body"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterMemFile2githubcomgnolangtxindexerservegraphmodelNestedFilterMemFile(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterMemFile2githubcomgnolangtxindexerservegraphmodelNestedFilterMemFile(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterMemFile2githubcomgnolangtxindexerservegraphmodelNestedFilterMemFile(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "body":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("body"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Body = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterMemPackage(ctx context.Context, obj interface{}) (model.NestedFilterMemPackage, error) {
	var it model.NestedFilterMemPackage
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "name", "path", "files"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterMemPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMemPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterMemPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMemPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterMemPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMemPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "files":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("files"))
			data, err := ec.unmarshalONestedFilterMemFile2githubcomgnolangtxindexerservegraphmodelNestedFilterMemFile(ctx, v)
			if err != nil {
				return it, err
			}
			it.Files = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterMessageValue(ctx context.Context, obj interface{}) (model.NestedFilterMessageValue, error) {
	var it model.NestedFilterMessageValue
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "BankMsgSend", "MsgCall", "MsgAddPackage", "MsgRun"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterMessageValue2githubcomgnolangtxindexerservegraphmodelNestedFilterMessageValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterMessageValue2githubcomgnolangtxindexerservegraphmodelNestedFilterMessageValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterMessageValue2githubcomgnolangtxindexerservegraphmodelNestedFilterMessageValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "BankMsgSend":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("BankMsgSend"))
			data, err := ec.unmarshalONestedFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelNestedFilterBankMsgSend(ctx, v)
			if err != nil {
				return it, err
			}
			it.BankMsgSend = data
		case "MsgCall":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("MsgCall"))
			data, err := ec.unmarshalONestedFilterMsgCall2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgCall(ctx, v)
			if err != nil {
				return it, err
			}
			it.MsgCall = data
		case "MsgAddPackage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("MsgAddPackage"))
			data, err := ec.unmarshalONestedFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgAddPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.MsgAddPackage = data
		case "MsgRun":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("MsgRun"))
			data, err := ec.unmarshalONestedFilterMsgRun2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgRun(ctx, v)
			if err != nil {
				return it, err
			}
			it.MsgRun = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterMsgAddPackage(ctx context.Context, obj interface{}) (model.NestedFilterMsgAddPackage, error) {
	var it model.NestedFilterMsgAddPackage
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "creator", "package", "deposit", "send", "max_deposit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgAddPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgAddPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgAddPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "creator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creator"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Creator = data
		case "package":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("package"))
			data, err := ec.unmarshalONestedFilterMemPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMemPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Package = data
		case "deposit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deposit"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Deposit = data
		case "send":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("send"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Send = data
		case "max_deposit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_deposit"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDeposit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterMsgCall(ctx context.Context, obj interface{}) (model.NestedFilterMsgCall, error) {
	var it model.NestedFilterMsgCall
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "caller", "send", "pkg_path", "func", "args", "max_deposit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterMsgCall2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgCall(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterMsgCall2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgCall(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterMsgCall2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgCall(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "caller":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caller"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caller = data
		case "send":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("send"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Send = data
		case "pkg_path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pkg_path"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.PkgPath = data
		case "func":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("func"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Func = data
		case "args":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("args"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Args = data
		case "max_deposit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_deposit"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDeposit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterMsgRun(ctx context.Context, obj interface{}) (model.NestedFilterMsgRun, error) {
	var it model.NestedFilterMsgRun
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "caller", "send", "package", "max_deposit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterMsgRun2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgRun(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterMsgRun2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgRun(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterMsgRun2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgRun(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "caller":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caller"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caller = data
		case "send":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("send"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Send = data
		case "package":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("package"))
			data, err := ec.unmarshalONestedFilterMemPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMemPackage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Package = data
		case "max_deposit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max_deposit"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDeposit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterTransactionMessage(ctx context.Context, obj interface{}) (model.NestedFilterTransactionMessage, error) {
	var it model.NestedFilterTransactionMessage
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "typeUrl", "route", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionMessage(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionMessage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionMessage(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "typeUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeUrl"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeURL = data
		case "route":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Route = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalONestedFilterMessageValue2githubcomgnolangtxindexerservegraphmodelNestedFilterMessageValue(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterTransactionResponse(ctx context.Context, obj interface{}) (model.NestedFilterTransactionResponse, error) {
	var it model.NestedFilterTransactionResponse
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "log", "info", "error", "data", "events"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionResponse(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionResponse(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionResponse(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "log":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("log"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Log = data
		case "info":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("info"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Info = data
		case "error":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("error"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Error = data
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "events":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("events"))
			data, err := ec.unmarshalONestedFilterEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Events = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterTxFee(ctx context.Context, obj interface{}) (model.NestedFilterTxFee, error) {
	var it model.NestedFilterTxFee
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "gas_wanted", "gas_fee"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterTxFee2githubcomgnolangtxindexerservegraphmodelNestedFilterTxFee(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterTxFee2githubcomgnolangtxindexerservegraphmodelNestedFilterTxFee(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterTxFee2githubcomgnolangtxindexerservegraphmodelNestedFilterTxFee(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "gas_wanted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gas_wanted"))
			data, err := ec.unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.GasWanted = data
		case "gas_fee":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gas_fee"))
			data, err := ec.unmarshalONestedFilterCoin2githubcomgnolangtxindexerservegraphmodelNestedFilterCoin(ctx, v)
			if err != nil {
				return it, err
			}
			it.GasFee = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNestedFilterUnknownEvent(ctx context.Context, obj interface{}) (model.NestedFilterUnknownEvent, error) {
	var it model.NestedFilterUnknownEvent
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_and", "_or", "_not", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_and"))
			data, err := ec.unmarshalONestedFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterUnknownEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "_or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_or"))
			data, err := ec.unmarshalONestedFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterUnknownEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "_not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_not"))
			data, err := ec.unmarshalONestedFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterUnknownEvent(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionBankMessageInput(ctx context.Context, obj interface{}) (model.TransactionBankMessageInput, error) {
	var it model.TransactionBankMessageInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"send"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "send":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("send"))
			data, err := ec.unmarshalOBankMsgSendInput2githubcomgnolangtxindexerservegraphmodelBankMsgSendInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Send = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionFilter(ctx context.Context, obj interface{}) (model.TransactionFilter, error) {
	var it model.TransactionFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"from_block_height", "to_block_height", "from_index", "to_index", "from_gas_wanted", "to_gas_wanted", "from_gas_used", "to_gas_used", "hash", "message", "memo", "success", "events"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "from_block_height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from_block_height"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromBlockHeight = data
		case "to_block_height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to_block_height"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToBlockHeight = data
		case "from_index":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from_index"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromIndex = data
		case "to_index":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to_index"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToIndex = data
		case "from_gas_wanted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from_gas_wanted"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromGasWanted = data
		case "to_gas_wanted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to_gas_wanted"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToGasWanted = data
		case "from_gas_used":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from_gas_used"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.FromGasUsed = data
		case "to_gas_used":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to_gas_used"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ToGasUsed = data
		case "hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hash = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalOTransactionMessageInput2githubcomgnolangtxindexerservegraphmodelTransactionMessageInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "memo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memo"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Memo = data
		case "success":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("success"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Success = data
		case "events":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("events"))
			data, err := ec.unmarshalOEventInput2githubcomgnolangtxindexerservegraphmodelEventInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Events = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionMessageInput(ctx context.Context, obj interface{}) (model.TransactionMessageInput, error) {
	var it model.TransactionMessageInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type_url", "route", "bank_param", "vm_param"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type_url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type_url"))
			data, err := ec.unmarshalOMessageType2githubcomgnolangtxindexerservegraphmodelMessageType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeURL = data
		case "route":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route"))
			data, err := ec.unmarshalOMessageRoute2githubcomgnolangtxindexerservegraphmodelMessageRoute(ctx, v)
			if err != nil {
				return it, err
			}
			it.Route = data
		case "bank_param":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bank_param"))
			data, err := ec.unmarshalOTransactionBankMessageInput2githubcomgnolangtxindexerservegraphmodelTransactionBankMessageInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.BankParam = data
		case "vm_param":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vm_param"))
			data, err := ec.unmarshalOTransactionVmMessageInput2githubcomgnolangtxindexerservegraphmodelTransactionVMMessageInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.VMParam = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionOrder(ctx context.Context, obj interface{}) (model.TransactionOrder, error) {
	var it model.TransactionOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"heightAndIndex"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "heightAndIndex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("heightAndIndex"))
			data, err := ec.unmarshalNOrder2githubcomgnolangtxindexerservegraphmodelOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it.HeightAndIndex = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTransactionVmMessageInput(ctx context.Context, obj interface{}) (model.TransactionVMMessageInput, error) {
	var it model.TransactionVMMessageInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"exec", "add_package", "run"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "exec":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exec"))
			data, err := ec.unmarshalOMsgCallInput2githubcomgnolangtxindexerservegraphmodelMsgCallInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Exec = data
		case "add_package":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("add_package"))
			data, err := ec.unmarshalOMsgAddPackageInput2githubcomgnolangtxindexerservegraphmodelMsgAddPackageInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddPackage = data
		case "run":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("run"))
			data, err := ec.unmarshalOMsgRunInput2githubcomgnolangtxindexerservegraphmodelMsgRunInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Run = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj model.Event) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.GnoEvent:
		return ec._GnoEvent(ctx, sel, &obj)
	case *model.GnoEvent:
		if obj == nil {
			return graphql.Null
		}
		return ec._GnoEvent(ctx, sel, obj)
	case model.UnknownEvent:
		return ec._UnknownEvent(ctx, sel, &obj)
	case *model.UnknownEvent:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnknownEvent(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _MessageValue(ctx context.Context, sel ast.SelectionSet, obj model.MessageValue) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.BankMsgSend:
		return ec._BankMsgSend(ctx, sel, &obj)
	case *model.BankMsgSend:
		if obj == nil {
			return graphql.Null
		}
		return ec._BankMsgSend(ctx, sel, obj)
	case model.MsgCall:
		return ec._MsgCall(ctx, sel, &obj)
	case *model.MsgCall:
		if obj == nil {
			return graphql.Null
		}
		return ec._MsgCall(ctx, sel, obj)
	case model.MsgAddPackage:
		return ec._MsgAddPackage(ctx, sel, &obj)
	case *model.MsgAddPackage:
		if obj == nil {
			return graphql.Null
		}
		return ec._MsgAddPackage(ctx, sel, obj)
	case model.MsgRun:
		return ec._MsgRun(ctx, sel, &obj)
	case *model.MsgRun:
		if obj == nil {
			return graphql.Null
		}
		return ec._MsgRun(ctx, sel, obj)
	case model.UnexpectedMessage:
		return ec._UnexpectedMessage(ctx, sel, &obj)
	case *model.UnexpectedMessage:
		if obj == nil {
			return graphql.Null
		}
		return ec._UnexpectedMessage(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var bankMsgSendImplementors = []string{"BankMsgSend", "MessageValue"}

func (ec *executionContext) _BankMsgSend(ctx context.Context, sel ast.SelectionSet, obj *model.BankMsgSend) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bankMsgSendImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BankMsgSend")
		case "from_address":
			out.Values[i] = ec._BankMsgSend_from_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "to_address":
			out.Values[i] = ec._BankMsgSend_to_address(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "amount":
			out.Values[i] = ec._BankMsgSend_amount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var blockImplementors = []string{"Block"}

func (ec *executionContext) _Block(ctx context.Context, sel ast.SelectionSet, obj *model.Block) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Block")
		case "hash":
			out.Values[i] = ec._Block_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "height":
			out.Values[i] = ec._Block_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Block_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "chain_id":
			out.Values[i] = ec._Block_chain_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "time":
			out.Values[i] = ec._Block_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "num_txs":
			out.Values[i] = ec._Block_num_txs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "total_txs":
			out.Values[i] = ec._Block_total_txs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "app_version":
			out.Values[i] = ec._Block_app_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "last_block_hash":
			out.Values[i] = ec._Block_last_block_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "last_commit_hash":
			out.Values[i] = ec._Block_last_commit_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "validators_hash":
			out.Values[i] = ec._Block_validators_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "next_validators_hash":
			out.Values[i] = ec._Block_next_validators_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "consensus_hash":
			out.Values[i] = ec._Block_consensus_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "app_hash":
			out.Values[i] = ec._Block_app_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "last_results_hash":
			out.Values[i] = ec._Block_last_results_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "proposer_address_raw":
			out.Values[i] = ec._Block_proposer_address_raw(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "txs":
			out.Values[i] = ec._Block_txs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var blockTransactionImplementors = []string{"BlockTransaction"}

func (ec *executionContext) _BlockTransaction(ctx context.Context, sel ast.SelectionSet, obj *model.BlockTransaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockTransactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockTransaction")
		case "hash":
			out.Values[i] = ec._BlockTransaction_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fee":
			out.Values[i] = ec._BlockTransaction_fee(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "memo":
			out.Values[i] = ec._BlockTransaction_memo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "content_raw":
			out.Values[i] = ec._BlockTransaction_content_raw(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var coinImplementors = []string{"Coin"}

func (ec *executionContext) _Coin(ctx context.Context, sel ast.SelectionSet, obj *model.Coin) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Coin")
		case "amount":
			out.Values[i] = ec._Coin_amount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "denom":
			out.Values[i] = ec._Coin_denom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gnoEventImplementors = []string{"GnoEvent", "Event"}

func (ec *executionContext) _GnoEvent(ctx context.Context, sel ast.SelectionSet, obj *model.GnoEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gnoEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GnoEvent")
		case "type":
			out.Values[i] = ec._GnoEvent_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pkg_path":
			out.Values[i] = ec._GnoEvent_pkg_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "func":
			out.Values[i] = ec._GnoEvent_func(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attrs":
			out.Values[i] = ec._GnoEvent_attrs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gnoEventAttributeImplementors = []string{"GnoEventAttribute"}

func (ec *executionContext) _GnoEventAttribute(ctx context.Context, sel ast.SelectionSet, obj *model.GnoEventAttribute) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gnoEventAttributeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GnoEventAttribute")
		case "key":
			out.Values[i] = ec._GnoEventAttribute_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._GnoEventAttribute_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var memFileImplementors = []string{"MemFile"}

func (ec *executionContext) _MemFile(ctx context.Context, sel ast.SelectionSet, obj *model.MemFile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, memFileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MemFile")
		case "name":
			out.Values[i] = ec._MemFile_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "body":
			out.Values[i] = ec._MemFile_body(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var memPackageImplementors = []string{"MemPackage"}

func (ec *executionContext) _MemPackage(ctx context.Context, sel ast.SelectionSet, obj *model.MemPackage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, memPackageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MemPackage")
		case "name":
			out.Values[i] = ec._MemPackage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "path":
			out.Values[i] = ec._MemPackage_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "files":
			out.Values[i] = ec._MemPackage_files(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var msgAddPackageImplementors = []string{"MsgAddPackage", "MessageValue"}

func (ec *executionContext) _MsgAddPackage(ctx context.Context, sel ast.SelectionSet, obj *model.MsgAddPackage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, msgAddPackageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MsgAddPackage")
		case "creator":
			out.Values[i] = ec._MsgAddPackage_creator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "package":
			out.Values[i] = ec._MsgAddPackage_package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deposit":
			out.Values[i] = ec._MsgAddPackage_deposit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "send":
			out.Values[i] = ec._MsgAddPackage_send(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "max_deposit":
			out.Values[i] = ec._MsgAddPackage_max_deposit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var msgCallImplementors = []string{"MsgCall", "MessageValue"}

func (ec *executionContext) _MsgCall(ctx context.Context, sel ast.SelectionSet, obj *model.MsgCall) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, msgCallImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MsgCall")
		case "caller":
			out.Values[i] = ec._MsgCall_caller(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "send":
			out.Values[i] = ec._MsgCall_send(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pkg_path":
			out.Values[i] = ec._MsgCall_pkg_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "func":
			out.Values[i] = ec._MsgCall_func(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec._MsgCall_args(ctx, field, obj)
		case "max_deposit":
			out.Values[i] = ec._MsgCall_max_deposit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var msgRunImplementors = []string{"MsgRun", "MessageValue"}

func (ec *executionContext) _MsgRun(ctx context.Context, sel ast.SelectionSet, obj *model.MsgRun) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, msgRunImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MsgRun")
		case "caller":
			out.Values[i] = ec._MsgRun_caller(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "send":
			out.Values[i] = ec._MsgRun_send(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "package":
			out.Values[i] = ec._MsgRun_package(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "max_deposit":
			out.Values[i] = ec._MsgRun_max_deposit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "transactions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_transactions(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "blocks":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_blocks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "latestBlockHeight":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_latestBlockHeight(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getBlocks":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getBlocks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getTransactions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getTransactions(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "transactions":
		return ec._Subscription_transactions(ctx, fields[0])
	case "blocks":
		return ec._Subscription_blocks(ctx, fields[0])
	case "getTransactions":
		return ec._Subscription_getTransactions(ctx, fields[0])
	case "getBlocks":
		return ec._Subscription_getBlocks(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var transactionImplementors = []string{"Transaction"}

func (ec *executionContext) _Transaction(ctx context.Context, sel ast.SelectionSet, obj *model.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "index":
			out.Values[i] = ec._Transaction_index(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hash":
			out.Values[i] = ec._Transaction_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "success":
			out.Values[i] = ec._Transaction_success(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "block_height":
			out.Values[i] = ec._Transaction_block_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gas_wanted":
			out.Values[i] = ec._Transaction_gas_wanted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gas_used":
			out.Values[i] = ec._Transaction_gas_used(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gas_fee":
			out.Values[i] = ec._Transaction_gas_fee(ctx, field, obj)
		case "content_raw":
			out.Values[i] = ec._Transaction_content_raw(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "messages":
			out.Values[i] = ec._Transaction_messages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "memo":
			out.Values[i] = ec._Transaction_memo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "response":
			out.Values[i] = ec._Transaction_response(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionMessageImplementors = []string{"TransactionMessage"}

func (ec *executionContext) _TransactionMessage(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionMessageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionMessage")
		case "typeUrl":
			out.Values[i] = ec._TransactionMessage_typeUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "route":
			out.Values[i] = ec._TransactionMessage_route(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._TransactionMessage_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var transactionResponseImplementors = []string{"TransactionResponse"}

func (ec *executionContext) _TransactionResponse(ctx context.Context, sel ast.SelectionSet, obj *model.TransactionResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, transactionResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransactionResponse")
		case "log":
			out.Values[i] = ec._TransactionResponse_log(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "info":
			out.Values[i] = ec._TransactionResponse_info(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._TransactionResponse_error(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._TransactionResponse_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._TransactionResponse_events(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var txFeeImplementors = []string{"TxFee"}

func (ec *executionContext) _TxFee(ctx context.Context, sel ast.SelectionSet, obj *model.TxFee) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, txFeeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TxFee")
		case "gas_wanted":
			out.Values[i] = ec._TxFee_gas_wanted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gas_fee":
			out.Values[i] = ec._TxFee_gas_fee(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unexpectedMessageImplementors = []string{"UnexpectedMessage", "MessageValue"}

func (ec *executionContext) _UnexpectedMessage(ctx context.Context, sel ast.SelectionSet, obj *model.UnexpectedMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unexpectedMessageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnexpectedMessage")
		case "raw":
			out.Values[i] = ec._UnexpectedMessage_raw(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var unknownEventImplementors = []string{"UnknownEvent", "Event"}

func (ec *executionContext) _UnknownEvent(ctx context.Context, sel ast.SelectionSet, obj *model.UnknownEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, unknownEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UnknownEvent")
		case "value":
			out.Values[i] = ec._UnknownEvent_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNBlock2githubcomgnolangtxindexerservegraphmodelBlock(ctx context.Context, sel ast.SelectionSet, v model.Block) graphql.Marshaler {
	return ec._Block(ctx, sel, &v)
}

func (ec *executionContext) marshalNBlock2githubcomgnolangtxindexerservegraphmodelBlock(ctx context.Context, sel ast.SelectionSet, v *model.Block) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Block(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBlockFilter2githubcomgnolangtxindexerservegraphmodelBlockFilter(ctx context.Context, v interface{}) (model.BlockFilter, error) {
	res, err := ec.unmarshalInputBlockFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBlockTransaction2githubcomgnolangtxindexerservegraphmodelBlockTransaction(ctx context.Context, sel ast.SelectionSet, v []*model.BlockTransaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBlockTransaction2githubcomgnolangtxindexerservegraphmodelBlockTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCoin2githubcomgnolangtxindexerservegraphmodelCoin(ctx context.Context, sel ast.SelectionSet, v *model.Coin) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Coin(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventAttributeInput2githubcomgnolangtxindexerservegraphmodelEventAttributeInput(ctx context.Context, v interface{}) (*model.EventAttributeInput, error) {
	res, err := ec.unmarshalInputEventAttributeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEventInput2githubcomgnolangtxindexerservegraphmodelEventInput(ctx context.Context, v interface{}) (*model.EventInput, error) {
	res, err := ec.unmarshalInputEventInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFilterBlock2githubcomgnolangtxindexerservegraphmodelFilterBlock(ctx context.Context, v interface{}) (model.FilterBlock, error) {
	res, err := ec.unmarshalInputFilterBlock(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFilterTransaction2githubcomgnolangtxindexerservegraphmodelFilterTransaction(ctx context.Context, v interface{}) (model.FilterTransaction, error) {
	res, err := ec.unmarshalInputFilterTransaction(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFilterableExtra2githubcomgnolangtxindexerservegraphmodelFilterableExtra(ctx context.Context, v interface{}) (model.FilterableExtra, error) {
	var res model.FilterableExtra
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFilterableExtra2githubcomgnolangtxindexerservegraphmodelFilterableExtra(ctx context.Context, sel ast.SelectionSet, v model.FilterableExtra) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelGnoEventAttribute(ctx context.Context, sel ast.SelectionSet, v *model.GnoEventAttribute) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GnoEventAttribute(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNMemFile2githubcomgnolangtxindexerservegraphmodelMemFile(ctx context.Context, sel ast.SelectionSet, v *model.MemFile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MemFile(ctx, sel, v)
}

func (ec *executionContext) marshalNMemPackage2githubcomgnolangtxindexerservegraphmodelMemPackage(ctx context.Context, sel ast.SelectionSet, v *model.MemPackage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MemPackage(ctx, sel, v)
}

func (ec *executionContext) marshalNMessageValue2githubcomgnolangtxindexerservegraphmodelMessageValue(ctx context.Context, sel ast.SelectionSet, v model.MessageValue) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MessageValue(ctx, sel, v)
}

func (ec *executionContext) unmarshalNOrder2githubcomgnolangtxindexerservegraphmodelOrder(ctx context.Context, v interface{}) (model.Order, error) {
	var res model.Order
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrder2githubcomgnolangtxindexerservegraphmodelOrder(ctx context.Context, sel ast.SelectionSet, v model.Order) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTransaction2githubcomgnolangtxindexerservegraphmodelTransaction(ctx context.Context, sel ast.SelectionSet, v model.Transaction) graphql.Marshaler {
	return ec._Transaction(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransaction2githubcomgnolangtxindexerservegraphmodelTransaction(ctx context.Context, sel ast.SelectionSet, v *model.Transaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Transaction(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTransactionFilter2githubcomgnolangtxindexerservegraphmodelTransactionFilter(ctx context.Context, v interface{}) (model.TransactionFilter, error) {
	res, err := ec.unmarshalInputTransactionFilter(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransactionMessage2githubcomgnolangtxindexerservegraphmodelTransactionMessage(ctx context.Context, sel ast.SelectionSet, v []*model.TransactionMessage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTransactionMessage2githubcomgnolangtxindexerservegraphmodelTransactionMessage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNTransactionMessageInput2githubcomgnolangtxindexerservegraphmodelTransactionMessageInput(ctx context.Context, v interface{}) (*model.TransactionMessageInput, error) {
	res, err := ec.unmarshalInputTransactionMessageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTransactionResponse2githubcomgnolangtxindexerservegraphmodelTransactionResponse(ctx context.Context, sel ast.SelectionSet, v *model.TransactionResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TransactionResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNTxFee2githubcomgnolangtxindexerservegraphmodelTxFee(ctx context.Context, sel ast.SelectionSet, v *model.TxFee) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TxFee(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAmountInput2githubcomgnolangtxindexerservegraphmodelAmountInput(ctx context.Context, v interface{}) (*model.AmountInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAmountInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBankMsgSendInput2githubcomgnolangtxindexerservegraphmodelBankMsgSendInput(ctx context.Context, v interface{}) (*model.BankMsgSendInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBankMsgSendInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBlock2githubcomgnolangtxindexerservegraphmodelBlock(ctx context.Context, sel ast.SelectionSet, v []*model.Block) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBlock2githubcomgnolangtxindexerservegraphmodelBlock(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBlockOrder2githubcomgnolangtxindexerservegraphmodelBlockOrder(ctx context.Context, v interface{}) (*model.BlockOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBlockOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBlockTransaction2githubcomgnolangtxindexerservegraphmodelBlockTransaction(ctx context.Context, sel ast.SelectionSet, v *model.BlockTransaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BlockTransaction(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCoin2githubcomgnolangtxindexerservegraphmodelCoin(ctx context.Context, sel ast.SelectionSet, v *model.Coin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Coin(ctx, sel, v)
}

func (ec *executionContext) marshalOEvent2githubcomgnolangtxindexerservegraphmodelEvent(ctx context.Context, sel ast.SelectionSet, v model.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) marshalOEvent2githubcomgnolangtxindexerservegraphmodelEvent(ctx context.Context, sel ast.SelectionSet, v []model.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEvent2githubcomgnolangtxindexerservegraphmodelEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalOEventAttributeInput2githubcomgnolangtxindexerservegraphmodelEventAttributeInput(ctx context.Context, v interface{}) ([]*model.EventAttributeInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.EventAttributeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEventAttributeInput2githubcomgnolangtxindexerservegraphmodelEventAttributeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOEventInput2githubcomgnolangtxindexerservegraphmodelEventInput(ctx context.Context, v interface{}) ([]*model.EventInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.EventInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEventInput2githubcomgnolangtxindexerservegraphmodelEventInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelFilterBankMsgSend(ctx context.Context, v interface{}) ([]*model.FilterBankMsgSend, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterBankMsgSend, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelFilterBankMsgSend(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelFilterBankMsgSend(ctx context.Context, v interface{}) (*model.FilterBankMsgSend, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterBankMsgSend(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterBlock2githubcomgnolangtxindexerservegraphmodelFilterBlock(ctx context.Context, v interface{}) ([]*model.FilterBlock, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterBlock, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterBlock2githubcomgnolangtxindexerservegraphmodelFilterBlock(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterBlock2githubcomgnolangtxindexerservegraphmodelFilterBlock(ctx context.Context, v interface{}) (*model.FilterBlock, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterBlock(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelFilterBlockTransaction(ctx context.Context, v interface{}) ([]*model.FilterBlockTransaction, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterBlockTransaction, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelFilterBlockTransaction(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelFilterBlockTransaction(ctx context.Context, v interface{}) (*model.FilterBlockTransaction, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterBlockTransaction(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterBoolean2githubcomgnolangtxindexerservegraphmodelFilterBoolean(ctx context.Context, v interface{}) (*model.FilterBoolean, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterBoolean(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterCoin2githubcomgnolangtxindexerservegraphmodelFilterCoin(ctx context.Context, v interface{}) ([]*model.FilterCoin, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterCoin, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterCoin2githubcomgnolangtxindexerservegraphmodelFilterCoin(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterCoin2githubcomgnolangtxindexerservegraphmodelFilterCoin(ctx context.Context, v interface{}) (*model.FilterCoin, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterCoin(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterEvent2githubcomgnolangtxindexerservegraphmodelFilterEvent(ctx context.Context, v interface{}) ([]*model.FilterEvent, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterEvent, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterEvent2githubcomgnolangtxindexerservegraphmodelFilterEvent(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterEvent2githubcomgnolangtxindexerservegraphmodelFilterEvent(ctx context.Context, v interface{}) (*model.FilterEvent, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterEvent(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelFilterGnoEvent(ctx context.Context, v interface{}) ([]*model.FilterGnoEvent, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterGnoEvent, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelFilterGnoEvent(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelFilterGnoEvent(ctx context.Context, v interface{}) (*model.FilterGnoEvent, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterGnoEvent(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelFilterGnoEventAttribute(ctx context.Context, v interface{}) ([]*model.FilterGnoEventAttribute, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterGnoEventAttribute, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelFilterGnoEventAttribute(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelFilterGnoEventAttribute(ctx context.Context, v interface{}) (*model.FilterGnoEventAttribute, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterGnoEventAttribute(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterInt2githubcomgnolangtxindexerservegraphmodelFilterInt(ctx context.Context, v interface{}) (*model.FilterInt, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterInt(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterMemFile2githubcomgnolangtxindexerservegraphmodelFilterMemFile(ctx context.Context, v interface{}) ([]*model.FilterMemFile, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterMemFile, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterMemFile2githubcomgnolangtxindexerservegraphmodelFilterMemFile(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterMemFile2githubcomgnolangtxindexerservegraphmodelFilterMemFile(ctx context.Context, v interface{}) (*model.FilterMemFile, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterMemFile(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterMemPackage2githubcomgnolangtxindexerservegraphmodelFilterMemPackage(ctx context.Context, v interface{}) ([]*model.FilterMemPackage, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterMemPackage, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterMemPackage2githubcomgnolangtxindexerservegraphmodelFilterMemPackage(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterMemPackage2githubcomgnolangtxindexerservegraphmodelFilterMemPackage(ctx context.Context, v interface{}) (*model.FilterMemPackage, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterMemPackage(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterMessageValue2githubcomgnolangtxindexerservegraphmodelFilterMessageValue(ctx context.Context, v interface{}) ([]*model.FilterMessageValue, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterMessageValue, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterMessageValue2githubcomgnolangtxindexerservegraphmodelFilterMessageValue(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterMessageValue2githubcomgnolangtxindexerservegraphmodelFilterMessageValue(ctx context.Context, v interface{}) (*model.FilterMessageValue, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterMessageValue(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelFilterMsgAddPackage(ctx context.Context, v interface{}) ([]*model.FilterMsgAddPackage, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterMsgAddPackage, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelFilterMsgAddPackage(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelFilterMsgAddPackage(ctx context.Context, v interface{}) (*model.FilterMsgAddPackage, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterMsgAddPackage(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterMsgCall2githubcomgnolangtxindexerservegraphmodelFilterMsgCall(ctx context.Context, v interface{}) ([]*model.FilterMsgCall, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterMsgCall, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterMsgCall2githubcomgnolangtxindexerservegraphmodelFilterMsgCall(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterMsgCall2githubcomgnolangtxindexerservegraphmodelFilterMsgCall(ctx context.Context, v interface{}) (*model.FilterMsgCall, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterMsgCall(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterMsgRun2githubcomgnolangtxindexerservegraphmodelFilterMsgRun(ctx context.Context, v interface{}) ([]*model.FilterMsgRun, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterMsgRun, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterMsgRun2githubcomgnolangtxindexerservegraphmodelFilterMsgRun(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterMsgRun2githubcomgnolangtxindexerservegraphmodelFilterMsgRun(ctx context.Context, v interface{}) (*model.FilterMsgRun, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterMsgRun(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterString2githubcomgnolangtxindexerservegraphmodelFilterString(ctx context.Context, v interface{}) (*model.FilterString, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterString(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterTime2githubcomgnolangtxindexerservegraphmodelFilterTime(ctx context.Context, v interface{}) (*model.FilterTime, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterTime(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterTransaction2githubcomgnolangtxindexerservegraphmodelFilterTransaction(ctx context.Context, v interface{}) ([]*model.FilterTransaction, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterTransaction, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterTransaction2githubcomgnolangtxindexerservegraphmodelFilterTransaction(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterTransaction2githubcomgnolangtxindexerservegraphmodelFilterTransaction(ctx context.Context, v interface{}) (*model.FilterTransaction, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterTransaction(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelFilterTransactionMessage(ctx context.Context, v interface{}) ([]*model.FilterTransactionMessage, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterTransactionMessage, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelFilterTransactionMessage(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelFilterTransactionMessage(ctx context.Context, v interface{}) (*model.FilterTransactionMessage, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterTransactionMessage(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelFilterTransactionResponse(ctx context.Context, v interface{}) ([]*model.FilterTransactionResponse, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterTransactionResponse, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelFilterTransactionResponse(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelFilterTransactionResponse(ctx context.Context, v interface{}) (*model.FilterTransactionResponse, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterTransactionResponse(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterTxFee2githubcomgnolangtxindexerservegraphmodelFilterTxFee(ctx context.Context, v interface{}) ([]*model.FilterTxFee, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterTxFee, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterTxFee2githubcomgnolangtxindexerservegraphmodelFilterTxFee(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterTxFee2githubcomgnolangtxindexerservegraphmodelFilterTxFee(ctx context.Context, v interface{}) (*model.FilterTxFee, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterTxFee(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelFilterUnknownEvent(ctx context.Context, v interface{}) ([]*model.FilterUnknownEvent, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FilterUnknownEvent, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelFilterUnknownEvent(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelFilterUnknownEvent(ctx context.Context, v interface{}) (*model.FilterUnknownEvent, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFilterUnknownEvent(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFilterableExtra2githubcomgnolangtxindexerservegraphmodelFilterableExtra(ctx context.Context, v interface{}) ([]model.FilterableExtra, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.FilterableExtra, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFilterableExtra2githubcomgnolangtxindexerservegraphmodelFilterableExtra(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFilterableExtra2githubcomgnolangtxindexerservegraphmodelFilterableExtra(ctx context.Context, sel ast.SelectionSet, v []model.FilterableExtra) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFilterableExtra2githubcomgnolangtxindexerservegraphmodelFilterableExtra(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelGnoEventAttribute(ctx context.Context, sel ast.SelectionSet, v []*model.GnoEventAttribute) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelGnoEventAttribute(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOMemFile2githubcomgnolangtxindexerservegraphmodelMemFile(ctx context.Context, sel ast.SelectionSet, v []*model.MemFile) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMemFile2githubcomgnolangtxindexerservegraphmodelMemFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMemFileInput2githubcomgnolangtxindexerservegraphmodelMemFileInput(ctx context.Context, v interface{}) ([]*model.MemFileInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MemFileInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOMemFileInput2githubcomgnolangtxindexerservegraphmodelMemFileInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOMemFileInput2githubcomgnolangtxindexerservegraphmodelMemFileInput(ctx context.Context, v interface{}) (*model.MemFileInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMemFileInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMemPackageInput2githubcomgnolangtxindexerservegraphmodelMemPackageInput(ctx context.Context, v interface{}) (*model.MemPackageInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMemPackageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMessageRoute2githubcomgnolangtxindexerservegraphmodelMessageRoute(ctx context.Context, v interface{}) (*model.MessageRoute, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MessageRoute)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMessageRoute2githubcomgnolangtxindexerservegraphmodelMessageRoute(ctx context.Context, sel ast.SelectionSet, v *model.MessageRoute) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOMessageType2githubcomgnolangtxindexerservegraphmodelMessageType(ctx context.Context, v interface{}) (*model.MessageType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MessageType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMessageType2githubcomgnolangtxindexerservegraphmodelMessageType(ctx context.Context, sel ast.SelectionSet, v *model.MessageType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOMsgAddPackageInput2githubcomgnolangtxindexerservegraphmodelMsgAddPackageInput(ctx context.Context, v interface{}) (*model.MsgAddPackageInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMsgAddPackageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMsgCallInput2githubcomgnolangtxindexerservegraphmodelMsgCallInput(ctx context.Context, v interface{}) (*model.MsgCallInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMsgCallInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOMsgRunInput2githubcomgnolangtxindexerservegraphmodelMsgRunInput(ctx context.Context, v interface{}) (*model.MsgRunInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMsgRunInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelNestedFilterBankMsgSend(ctx context.Context, v interface{}) ([]*model.NestedFilterBankMsgSend, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterBankMsgSend, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelNestedFilterBankMsgSend(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterBankMsgSend2githubcomgnolangtxindexerservegraphmodelNestedFilterBankMsgSend(ctx context.Context, v interface{}) (*model.NestedFilterBankMsgSend, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterBankMsgSend(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelNestedFilterBlockTransaction(ctx context.Context, v interface{}) ([]*model.NestedFilterBlockTransaction, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterBlockTransaction, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelNestedFilterBlockTransaction(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterBlockTransaction2githubcomgnolangtxindexerservegraphmodelNestedFilterBlockTransaction(ctx context.Context, v interface{}) (*model.NestedFilterBlockTransaction, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterBlockTransaction(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterCoin2githubcomgnolangtxindexerservegraphmodelNestedFilterCoin(ctx context.Context, v interface{}) ([]*model.NestedFilterCoin, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterCoin, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterCoin2githubcomgnolangtxindexerservegraphmodelNestedFilterCoin(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterCoin2githubcomgnolangtxindexerservegraphmodelNestedFilterCoin(ctx context.Context, v interface{}) (*model.NestedFilterCoin, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterCoin(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterEvent(ctx context.Context, v interface{}) ([]*model.NestedFilterEvent, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterEvent, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterEvent(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterEvent(ctx context.Context, v interface{}) (*model.NestedFilterEvent, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterEvent(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEvent(ctx context.Context, v interface{}) ([]*model.NestedFilterGnoEvent, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterGnoEvent, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEvent(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterGnoEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEvent(ctx context.Context, v interface{}) (*model.NestedFilterGnoEvent, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterGnoEvent(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEventAttribute(ctx context.Context, v interface{}) ([]*model.NestedFilterGnoEventAttribute, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterGnoEventAttribute, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEventAttribute(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterGnoEventAttribute2githubcomgnolangtxindexerservegraphmodelNestedFilterGnoEventAttribute(ctx context.Context, v interface{}) (*model.NestedFilterGnoEventAttribute, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterGnoEventAttribute(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterMemFile2githubcomgnolangtxindexerservegraphmodelNestedFilterMemFile(ctx context.Context, v interface{}) ([]*model.NestedFilterMemFile, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterMemFile, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterMemFile2githubcomgnolangtxindexerservegraphmodelNestedFilterMemFile(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterMemFile2githubcomgnolangtxindexerservegraphmodelNestedFilterMemFile(ctx context.Context, v interface{}) (*model.NestedFilterMemFile, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterMemFile(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterMemPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMemPackage(ctx context.Context, v interface{}) ([]*model.NestedFilterMemPackage, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterMemPackage, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterMemPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMemPackage(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterMemPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMemPackage(ctx context.Context, v interface{}) (*model.NestedFilterMemPackage, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterMemPackage(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterMessageValue2githubcomgnolangtxindexerservegraphmodelNestedFilterMessageValue(ctx context.Context, v interface{}) ([]*model.NestedFilterMessageValue, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterMessageValue, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterMessageValue2githubcomgnolangtxindexerservegraphmodelNestedFilterMessageValue(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterMessageValue2githubcomgnolangtxindexerservegraphmodelNestedFilterMessageValue(ctx context.Context, v interface{}) (*model.NestedFilterMessageValue, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterMessageValue(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgAddPackage(ctx context.Context, v interface{}) ([]*model.NestedFilterMsgAddPackage, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterMsgAddPackage, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgAddPackage(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterMsgAddPackage2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgAddPackage(ctx context.Context, v interface{}) (*model.NestedFilterMsgAddPackage, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterMsgAddPackage(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterMsgCall2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgCall(ctx context.Context, v interface{}) ([]*model.NestedFilterMsgCall, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterMsgCall, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterMsgCall2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgCall(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterMsgCall2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgCall(ctx context.Context, v interface{}) (*model.NestedFilterMsgCall, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterMsgCall(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterMsgRun2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgRun(ctx context.Context, v interface{}) ([]*model.NestedFilterMsgRun, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterMsgRun, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterMsgRun2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgRun(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterMsgRun2githubcomgnolangtxindexerservegraphmodelNestedFilterMsgRun(ctx context.Context, v interface{}) (*model.NestedFilterMsgRun, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterMsgRun(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionMessage(ctx context.Context, v interface{}) ([]*model.NestedFilterTransactionMessage, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterTransactionMessage, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionMessage(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterTransactionMessage2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionMessage(ctx context.Context, v interface{}) (*model.NestedFilterTransactionMessage, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterTransactionMessage(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionResponse(ctx context.Context, v interface{}) ([]*model.NestedFilterTransactionResponse, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterTransactionResponse, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionResponse(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterTransactionResponse2githubcomgnolangtxindexerservegraphmodelNestedFilterTransactionResponse(ctx context.Context, v interface{}) (*model.NestedFilterTransactionResponse, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterTransactionResponse(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterTxFee2githubcomgnolangtxindexerservegraphmodelNestedFilterTxFee(ctx context.Context, v interface{}) ([]*model.NestedFilterTxFee, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterTxFee, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterTxFee2githubcomgnolangtxindexerservegraphmodelNestedFilterTxFee(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterTxFee2githubcomgnolangtxindexerservegraphmodelNestedFilterTxFee(ctx context.Context, v interface{}) (*model.NestedFilterTxFee, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterTxFee(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalONestedFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterUnknownEvent(ctx context.Context, v interface{}) ([]*model.NestedFilterUnknownEvent, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.NestedFilterUnknownEvent, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalONestedFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterUnknownEvent(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalONestedFilterUnknownEvent2githubcomgnolangtxindexerservegraphmodelNestedFilterUnknownEvent(ctx context.Context, v interface{}) (*model.NestedFilterUnknownEvent, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNestedFilterUnknownEvent(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTransaction2githubcomgnolangtxindexerservegraphmodelTransaction(ctx context.Context, sel ast.SelectionSet, v []*model.Transaction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransaction2githubcomgnolangtxindexerservegraphmodelTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTransactionBankMessageInput2githubcomgnolangtxindexerservegraphmodelTransactionBankMessageInput(ctx context.Context, v interface{}) (*model.TransactionBankMessageInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionBankMessageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTransactionMessage2githubcomgnolangtxindexerservegraphmodelTransactionMessage(ctx context.Context, sel ast.SelectionSet, v *model.TransactionMessage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TransactionMessage(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTransactionMessageInput2githubcomgnolangtxindexerservegraphmodelTransactionMessageInput(ctx context.Context, v interface{}) ([]*model.TransactionMessageInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.TransactionMessageInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTransactionMessageInput2githubcomgnolangtxindexerservegraphmodelTransactionMessageInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTransactionOrder2githubcomgnolangtxindexerservegraphmodelTransactionOrder(ctx context.Context, v interface{}) (*model.TransactionOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTransactionVmMessageInput2githubcomgnolangtxindexerservegraphmodelTransactionVMMessageInput(ctx context.Context, v interface{}) (*model.TransactionVMMessageInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTransactionVmMessageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
