// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"regexp"
	"time"
)

///////////////////////////////// CUSTOM  TYPES /////////////////////////////////

func (f *NestedFilterUnknownEvent) Eval(obj *UnknownEvent) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Value field
	toEvalValue := obj.Value
	if f.Value != nil && !f.Value.Eval(&toEvalValue) {
		return false
	}

	return true
}

func (f *NestedFilterTxFee) Eval(obj *TxFee) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle GasWanted field
	toEvalGasWanted := toIntPtr(obj.GasWanted)
	if f.GasWanted != nil && !f.GasWanted.Eval(toEvalGasWanted) {
		return false
	}

	// Handle GasFee field
	toEvalGasFee := obj.GasFee
	if f.GasFee != nil && !f.GasFee.Eval(toEvalGasFee) {
		return false
	}

	return true
}

func (f *NestedFilterTransactionResponse) Eval(obj *TransactionResponse) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Log field
	toEvalLog := obj.Log()
	if f.Log != nil && !f.Log.Eval(&toEvalLog) {
		return false
	}

	// Handle Info field
	toEvalInfo := obj.Info()
	if f.Info != nil && !f.Info.Eval(&toEvalInfo) {
		return false
	}

	// Handle Events slice
	if f.Events != nil {
		elemMatchEvents := false
		for _, elem := range obj.Events() {
			if f.Events.Eval(&elem) {
				elemMatchEvents = true
			}
		}

		if !elemMatchEvents {
			return false
		}

	}

	// Handle Error field
	toEvalError := obj.Error()
	if f.Error != nil && !f.Error.Eval(&toEvalError) {
		return false
	}

	// Handle Data field
	toEvalData := obj.Data()
	if f.Data != nil && !f.Data.Eval(&toEvalData) {
		return false
	}

	return true
}

func (f *NestedFilterTransactionMessage) Eval(obj *TransactionMessage) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Value field
	toEvalValue := obj.Value
	if f.Value != nil && !f.Value.Eval(&toEvalValue) {
		return false
	}

	// Handle TypeURL field
	toEvalTypeURL := obj.TypeURL
	if f.TypeURL != nil && !f.TypeURL.Eval(&toEvalTypeURL) {
		return false
	}

	// Handle Route field
	toEvalRoute := obj.Route
	if f.Route != nil && !f.Route.Eval(&toEvalRoute) {
		return false
	}

	return true
}

func (f *NestedFilterStorageUnlockEvent) Eval(obj *StorageUnlockEvent) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Type field
	toEvalType := obj.Type
	if f.Type != nil && !f.Type.Eval(&toEvalType) {
		return false
	}

	// Handle PkgPath field
	toEvalPkgPath := obj.PkgPath
	if f.PkgPath != nil && !f.PkgPath.Eval(&toEvalPkgPath) {
		return false
	}

	// Handle FeeRefund field
	toEvalFeeRefund := obj.FeeRefund
	if f.FeeRefund != nil && !f.FeeRefund.Eval(toEvalFeeRefund) {
		return false
	}

	// Handle BytesDelta field
	toEvalBytesDelta := toIntPtr(obj.BytesDelta)
	if f.BytesDelta != nil && !f.BytesDelta.Eval(toEvalBytesDelta) {
		return false
	}

	return true
}

func (f *NestedFilterStorageDepositEvent) Eval(obj *StorageDepositEvent) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Type field
	toEvalType := obj.Type
	if f.Type != nil && !f.Type.Eval(&toEvalType) {
		return false
	}

	// Handle PkgPath field
	toEvalPkgPath := obj.PkgPath
	if f.PkgPath != nil && !f.PkgPath.Eval(&toEvalPkgPath) {
		return false
	}

	// Handle FeeDelta field
	toEvalFeeDelta := obj.FeeDelta
	if f.FeeDelta != nil && !f.FeeDelta.Eval(toEvalFeeDelta) {
		return false
	}

	// Handle BytesDelta field
	toEvalBytesDelta := toIntPtr(obj.BytesDelta)
	if f.BytesDelta != nil && !f.BytesDelta.Eval(toEvalBytesDelta) {
		return false
	}

	return true
}

func (f *NestedFilterMsgRun) Eval(obj *MsgRun) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Send field
	toEvalSend := obj.Send
	if f.Send != nil && !f.Send.Eval(&toEvalSend) {
		return false
	}

	// Handle Package field
	toEvalPackage := obj.Package
	if f.Package != nil && !f.Package.Eval(toEvalPackage) {
		return false
	}

	// Handle MaxDeposit field
	toEvalMaxDeposit := obj.MaxDeposit
	if f.MaxDeposit != nil && !f.MaxDeposit.Eval(&toEvalMaxDeposit) {
		return false
	}

	// Handle Caller field
	toEvalCaller := obj.Caller
	if f.Caller != nil && !f.Caller.Eval(&toEvalCaller) {
		return false
	}

	return true
}

func (f *NestedFilterMsgCall) Eval(obj *MsgCall) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Send field
	toEvalSend := obj.Send
	if f.Send != nil && !f.Send.Eval(&toEvalSend) {
		return false
	}

	// Handle PkgPath field
	toEvalPkgPath := obj.PkgPath
	if f.PkgPath != nil && !f.PkgPath.Eval(&toEvalPkgPath) {
		return false
	}

	// Handle MaxDeposit field
	toEvalMaxDeposit := obj.MaxDeposit
	if f.MaxDeposit != nil && !f.MaxDeposit.Eval(&toEvalMaxDeposit) {
		return false
	}

	// Handle Func field
	toEvalFunc := obj.Func
	if f.Func != nil && !f.Func.Eval(&toEvalFunc) {
		return false
	}

	// Handle Caller field
	toEvalCaller := obj.Caller
	if f.Caller != nil && !f.Caller.Eval(&toEvalCaller) {
		return false
	}

	// Handle Args slice
	if f.Args != nil {
		elemMatchArgs := false
		for _, elem := range obj.Args {
			if f.Args.Eval(&elem) {
				elemMatchArgs = true
			}
		}

		if !elemMatchArgs {
			return false
		}

	}

	return true
}

func (f *NestedFilterMsgAddPackage) Eval(obj *MsgAddPackage) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Send field
	toEvalSend := obj.Send
	if f.Send != nil && !f.Send.Eval(&toEvalSend) {
		return false
	}

	// Handle Package field
	toEvalPackage := obj.Package
	if f.Package != nil && !f.Package.Eval(toEvalPackage) {
		return false
	}

	// Handle MaxDeposit field
	toEvalMaxDeposit := obj.MaxDeposit
	if f.MaxDeposit != nil && !f.MaxDeposit.Eval(&toEvalMaxDeposit) {
		return false
	}

	// Handle Deposit field
	toEvalDeposit := obj.Deposit
	if f.Deposit != nil && !f.Deposit.Eval(&toEvalDeposit) {
		return false
	}

	// Handle Creator field
	toEvalCreator := obj.Creator
	if f.Creator != nil && !f.Creator.Eval(&toEvalCreator) {
		return false
	}

	return true
}

func (f *NestedFilterMessageValue) Eval(obj *MessageValue) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Handle union objects depending of the type

	// Check if any filters are specified
	filtersSpecified := f.BankMsgSend != nil || f.MsgCall != nil || f.MsgAddPackage != nil || f.MsgRun != nil || false

	// If no filters are specified for any types, accept all objects
	if !filtersSpecified {
		return true
	}

	// Evaluate specified type filters
	matchedType := false

	tobj := *obj
	if uObj, ok := tobj.(BankMsgSend); ok {
		matchedType = true
		if f.BankMsgSend != nil && f.BankMsgSend.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*BankMsgSend); ok {
		matchedType = true
		if f.BankMsgSend != nil && f.BankMsgSend.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(MsgCall); ok {
		matchedType = true
		if f.MsgCall != nil && f.MsgCall.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*MsgCall); ok {
		matchedType = true
		if f.MsgCall != nil && f.MsgCall.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(MsgAddPackage); ok {
		matchedType = true
		if f.MsgAddPackage != nil && f.MsgAddPackage.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*MsgAddPackage); ok {
		matchedType = true
		if f.MsgAddPackage != nil && f.MsgAddPackage.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(MsgRun); ok {
		matchedType = true
		if f.MsgRun != nil && f.MsgRun.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*MsgRun); ok {
		matchedType = true
		if f.MsgRun != nil && f.MsgRun.Eval(uObj) {
			return true
		}
	}

	// If the object is of a type specified in filters but didn't match, return false.
	if matchedType {
		return false
	}

	return true
}

func (f *NestedFilterMemPackage) Eval(obj *MemPackage) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Path field
	toEvalPath := obj.Path
	if f.Path != nil && !f.Path.Eval(&toEvalPath) {
		return false
	}

	// Handle Name field
	toEvalName := obj.Name
	if f.Name != nil && !f.Name.Eval(&toEvalName) {
		return false
	}

	// Handle Files slice
	if f.Files != nil {
		elemMatchFiles := false
		for _, elem := range obj.Files {
			if f.Files.Eval(elem) {
				elemMatchFiles = true
			}
		}

		if !elemMatchFiles {
			return false
		}

	}

	return true
}

func (f *NestedFilterMemFile) Eval(obj *MemFile) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Name field
	toEvalName := obj.Name
	if f.Name != nil && !f.Name.Eval(&toEvalName) {
		return false
	}

	// Handle Body field
	toEvalBody := obj.Body
	if f.Body != nil && !f.Body.Eval(&toEvalBody) {
		return false
	}

	return true
}

func (f *NestedFilterGnoEventAttribute) Eval(obj *GnoEventAttribute) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Value field
	toEvalValue := obj.Value
	if f.Value != nil && !f.Value.Eval(&toEvalValue) {
		return false
	}

	// Handle Key field
	toEvalKey := obj.Key
	if f.Key != nil && !f.Key.Eval(&toEvalKey) {
		return false
	}

	return true
}

func (f *NestedFilterGnoEvent) Eval(obj *GnoEvent) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Type field
	toEvalType := obj.Type
	if f.Type != nil && !f.Type.Eval(&toEvalType) {
		return false
	}

	// Handle PkgPath field
	toEvalPkgPath := obj.PkgPath
	if f.PkgPath != nil && !f.PkgPath.Eval(&toEvalPkgPath) {
		return false
	}

	// Handle Func field
	toEvalFunc := obj.Func
	if f.Func != nil && !f.Func.Eval(&toEvalFunc) {
		return false
	}

	// Handle Attrs slice
	if f.Attrs != nil {
		elemMatchAttrs := false
		for _, elem := range obj.Attrs {
			if f.Attrs.Eval(elem) {
				elemMatchAttrs = true
			}
		}

		if !elemMatchAttrs {
			return false
		}

	}

	return true
}

func (f *NestedFilterEvent) Eval(obj *Event) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Handle union objects depending of the type

	// Check if any filters are specified
	filtersSpecified := f.GnoEvent != nil || f.StorageDepositEvent != nil || f.StorageUnlockEvent != nil || f.UnknownEvent != nil || false

	// If no filters are specified for any types, accept all objects
	if !filtersSpecified {
		return true
	}

	// Evaluate specified type filters
	matchedType := false

	tobj := *obj
	if uObj, ok := tobj.(GnoEvent); ok {
		matchedType = true
		if f.GnoEvent != nil && f.GnoEvent.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*GnoEvent); ok {
		matchedType = true
		if f.GnoEvent != nil && f.GnoEvent.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(StorageDepositEvent); ok {
		matchedType = true
		if f.StorageDepositEvent != nil && f.StorageDepositEvent.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*StorageDepositEvent); ok {
		matchedType = true
		if f.StorageDepositEvent != nil && f.StorageDepositEvent.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(StorageUnlockEvent); ok {
		matchedType = true
		if f.StorageUnlockEvent != nil && f.StorageUnlockEvent.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*StorageUnlockEvent); ok {
		matchedType = true
		if f.StorageUnlockEvent != nil && f.StorageUnlockEvent.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(UnknownEvent); ok {
		matchedType = true
		if f.UnknownEvent != nil && f.UnknownEvent.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*UnknownEvent); ok {
		matchedType = true
		if f.UnknownEvent != nil && f.UnknownEvent.Eval(uObj) {
			return true
		}
	}

	// If the object is of a type specified in filters but didn't match, return false.
	if matchedType {
		return false
	}

	return true
}

func (f *NestedFilterCoin) Eval(obj *Coin) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Denom field
	toEvalDenom := obj.Denom
	if f.Denom != nil && !f.Denom.Eval(&toEvalDenom) {
		return false
	}

	// Handle Amount field
	toEvalAmount := toIntPtr(obj.Amount)
	if f.Amount != nil && !f.Amount.Eval(toEvalAmount) {
		return false
	}

	return true
}

func (f *NestedFilterBlockTransaction) Eval(obj *BlockTransaction) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Memo field
	toEvalMemo := obj.Memo
	if f.Memo != nil && !f.Memo.Eval(&toEvalMemo) {
		return false
	}

	// Handle Hash field
	toEvalHash := obj.Hash
	if f.Hash != nil && !f.Hash.Eval(&toEvalHash) {
		return false
	}

	// Handle Fee field
	toEvalFee := obj.Fee
	if f.Fee != nil && !f.Fee.Eval(toEvalFee) {
		return false
	}

	return true
}

func (f *NestedFilterBankMsgSend) Eval(obj *BankMsgSend) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle ToAddress field
	toEvalToAddress := obj.ToAddress
	if f.ToAddress != nil && !f.ToAddress.Eval(&toEvalToAddress) {
		return false
	}

	// Handle FromAddress field
	toEvalFromAddress := obj.FromAddress
	if f.FromAddress != nil && !f.FromAddress.Eval(&toEvalFromAddress) {
		return false
	}

	// Handle Amount field
	toEvalAmount := obj.Amount
	if f.Amount != nil && !f.Amount.Eval(&toEvalAmount) {
		return false
	}

	return true
}

func (f *FilterUnknownEvent) Eval(obj *UnknownEvent) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Value field
	toEvalValue := obj.Value
	if f.Value != nil && !f.Value.Eval(&toEvalValue) {
		return false
	}

	return true
}

func (f *FilterTxFee) Eval(obj *TxFee) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle GasWanted field
	toEvalGasWanted := toIntPtr(obj.GasWanted)
	if f.GasWanted != nil && !f.GasWanted.Eval(toEvalGasWanted) {
		return false
	}

	// Handle GasFee field
	toEvalGasFee := obj.GasFee
	if f.GasFee != nil && !f.GasFee.Eval(toEvalGasFee) {
		return false
	}

	return true
}

func (f *FilterTransactionResponse) Eval(obj *TransactionResponse) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Log field
	toEvalLog := obj.Log()
	if f.Log != nil && !f.Log.Eval(&toEvalLog) {
		return false
	}

	// Handle Info field
	toEvalInfo := obj.Info()
	if f.Info != nil && !f.Info.Eval(&toEvalInfo) {
		return false
	}

	// Handle Events slice
	if f.Events != nil {
		elemMatchEvents := false
		for _, elem := range obj.Events() {
			if f.Events.Eval(&elem) {
				elemMatchEvents = true
			}
		}

		if !elemMatchEvents {
			return false
		}

	}

	// Handle Error field
	toEvalError := obj.Error()
	if f.Error != nil && !f.Error.Eval(&toEvalError) {
		return false
	}

	// Handle Data field
	toEvalData := obj.Data()
	if f.Data != nil && !f.Data.Eval(&toEvalData) {
		return false
	}

	return true
}

func (f *FilterTransactionMessage) Eval(obj *TransactionMessage) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Value field
	toEvalValue := obj.Value
	if f.Value != nil && !f.Value.Eval(&toEvalValue) {
		return false
	}

	// Handle TypeURL field
	toEvalTypeURL := obj.TypeURL
	if f.TypeURL != nil && !f.TypeURL.Eval(&toEvalTypeURL) {
		return false
	}

	// Handle Route field
	toEvalRoute := obj.Route
	if f.Route != nil && !f.Route.Eval(&toEvalRoute) {
		return false
	}

	return true
}

func (f *FilterTransaction) Eval(obj *Transaction) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Success field
	toEvalSuccess := obj.Success()
	if f.Success != nil && !f.Success.Eval(&toEvalSuccess) {
		return false
	}

	// Handle Response field
	toEvalResponse := obj.Response()
	if f.Response != nil && !f.Response.Eval(toEvalResponse) {
		return false
	}

	// Handle Messages slice
	if f.Messages != nil {
		elemMatchMessages := false
		for _, elem := range obj.Messages() {
			if f.Messages.Eval(elem) {
				elemMatchMessages = true
			}
		}

		if !elemMatchMessages {
			return false
		}

	}

	// Handle Memo field
	toEvalMemo := obj.Memo()
	if f.Memo != nil && !f.Memo.Eval(&toEvalMemo) {
		return false
	}

	// Handle Index field
	toEvalIndex := toIntPtr(obj.Index())
	if f.Index != nil && !f.Index.Eval(toEvalIndex) {
		return false
	}

	// Handle Hash field
	toEvalHash := obj.Hash()
	if f.Hash != nil && !f.Hash.Eval(&toEvalHash) {
		return false
	}

	// Handle GasWanted field
	toEvalGasWanted := toIntPtr(obj.GasWanted())
	if f.GasWanted != nil && !f.GasWanted.Eval(toEvalGasWanted) {
		return false
	}

	// Handle GasUsed field
	toEvalGasUsed := toIntPtr(obj.GasUsed())
	if f.GasUsed != nil && !f.GasUsed.Eval(toEvalGasUsed) {
		return false
	}

	// Handle GasFee field
	toEvalGasFee := obj.GasFee()
	if f.GasFee != nil && !f.GasFee.Eval(toEvalGasFee) {
		return false
	}

	// Handle BlockHeight field
	toEvalBlockHeight := toIntPtr(obj.BlockHeight())
	if f.BlockHeight != nil && !f.BlockHeight.Eval(toEvalBlockHeight) {
		return false
	}

	return true
}

// MinMax function for Index
func (f *FilterTransaction) MinMaxIndex() (min *int, max *int) {
	// Recursively handle And conditions
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			subMin, subMax := subFilter.MinMaxIndex()
			if subMin != nil && (min == nil || *subMin < *min) {
				min = subMin
			}
			if subMax != nil && (max == nil || *subMax > *max) {
				max = subMax
			}
		}
	}

	// Recursively handle Or conditions
	if len(f.Or) > 0 {
		for _, subFilter := range f.Or {
			subMin, subMax := subFilter.MinMaxIndex()
			if subMin != nil && (min == nil || *subMin < *min) {
				min = subMin
			}
			if subMax != nil && (max == nil || *subMax > *max) {
				max = subMax
			}
		}
	}

	if f.Index != nil {
		if f.Index.Gt != nil {
			if min == nil || *f.Index.Gt < *min {
				min = f.Index.Gt
			}
		}

		if f.Index.Lt != nil {
			if max == nil || *f.Index.Lt > *max {
				max = f.Index.Lt
			}
		}

		if f.Index.Eq != nil {
			if min == nil || *f.Index.Eq < *min {
				min = f.Index.Eq
			}
			if max == nil || *f.Index.Eq > *max {
				max = f.Index.Eq
			}
		}
	}

	return min, max
}

// MinMax function for BlockHeight
func (f *FilterTransaction) MinMaxBlockHeight() (min *int, max *int) {
	// Recursively handle And conditions
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			subMin, subMax := subFilter.MinMaxBlockHeight()
			if subMin != nil && (min == nil || *subMin < *min) {
				min = subMin
			}
			if subMax != nil && (max == nil || *subMax > *max) {
				max = subMax
			}
		}
	}

	// Recursively handle Or conditions
	if len(f.Or) > 0 {
		for _, subFilter := range f.Or {
			subMin, subMax := subFilter.MinMaxBlockHeight()
			if subMin != nil && (min == nil || *subMin < *min) {
				min = subMin
			}
			if subMax != nil && (max == nil || *subMax > *max) {
				max = subMax
			}
		}
	}

	if f.BlockHeight != nil {
		if f.BlockHeight.Gt != nil {
			if min == nil || *f.BlockHeight.Gt < *min {
				min = f.BlockHeight.Gt
			}
		}

		if f.BlockHeight.Lt != nil {
			if max == nil || *f.BlockHeight.Lt > *max {
				max = f.BlockHeight.Lt
			}
		}

		if f.BlockHeight.Eq != nil {
			if min == nil || *f.BlockHeight.Eq < *min {
				min = f.BlockHeight.Eq
			}
			if max == nil || *f.BlockHeight.Eq > *max {
				max = f.BlockHeight.Eq
			}
		}
	}

	return min, max
}

func (f *FilterStorageUnlockEvent) Eval(obj *StorageUnlockEvent) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Type field
	toEvalType := obj.Type
	if f.Type != nil && !f.Type.Eval(&toEvalType) {
		return false
	}

	// Handle PkgPath field
	toEvalPkgPath := obj.PkgPath
	if f.PkgPath != nil && !f.PkgPath.Eval(&toEvalPkgPath) {
		return false
	}

	// Handle FeeRefund field
	toEvalFeeRefund := obj.FeeRefund
	if f.FeeRefund != nil && !f.FeeRefund.Eval(toEvalFeeRefund) {
		return false
	}

	// Handle BytesDelta field
	toEvalBytesDelta := toIntPtr(obj.BytesDelta)
	if f.BytesDelta != nil && !f.BytesDelta.Eval(toEvalBytesDelta) {
		return false
	}

	return true
}

func (f *FilterStorageDepositEvent) Eval(obj *StorageDepositEvent) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Type field
	toEvalType := obj.Type
	if f.Type != nil && !f.Type.Eval(&toEvalType) {
		return false
	}

	// Handle PkgPath field
	toEvalPkgPath := obj.PkgPath
	if f.PkgPath != nil && !f.PkgPath.Eval(&toEvalPkgPath) {
		return false
	}

	// Handle FeeDelta field
	toEvalFeeDelta := obj.FeeDelta
	if f.FeeDelta != nil && !f.FeeDelta.Eval(toEvalFeeDelta) {
		return false
	}

	// Handle BytesDelta field
	toEvalBytesDelta := toIntPtr(obj.BytesDelta)
	if f.BytesDelta != nil && !f.BytesDelta.Eval(toEvalBytesDelta) {
		return false
	}

	return true
}

func (f *FilterMsgRun) Eval(obj *MsgRun) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Send field
	toEvalSend := obj.Send
	if f.Send != nil && !f.Send.Eval(&toEvalSend) {
		return false
	}

	// Handle Package field
	toEvalPackage := obj.Package
	if f.Package != nil && !f.Package.Eval(toEvalPackage) {
		return false
	}

	// Handle MaxDeposit field
	toEvalMaxDeposit := obj.MaxDeposit
	if f.MaxDeposit != nil && !f.MaxDeposit.Eval(&toEvalMaxDeposit) {
		return false
	}

	// Handle Caller field
	toEvalCaller := obj.Caller
	if f.Caller != nil && !f.Caller.Eval(&toEvalCaller) {
		return false
	}

	return true
}

func (f *FilterMsgCall) Eval(obj *MsgCall) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Send field
	toEvalSend := obj.Send
	if f.Send != nil && !f.Send.Eval(&toEvalSend) {
		return false
	}

	// Handle PkgPath field
	toEvalPkgPath := obj.PkgPath
	if f.PkgPath != nil && !f.PkgPath.Eval(&toEvalPkgPath) {
		return false
	}

	// Handle MaxDeposit field
	toEvalMaxDeposit := obj.MaxDeposit
	if f.MaxDeposit != nil && !f.MaxDeposit.Eval(&toEvalMaxDeposit) {
		return false
	}

	// Handle Func field
	toEvalFunc := obj.Func
	if f.Func != nil && !f.Func.Eval(&toEvalFunc) {
		return false
	}

	// Handle Caller field
	toEvalCaller := obj.Caller
	if f.Caller != nil && !f.Caller.Eval(&toEvalCaller) {
		return false
	}

	// Handle Args slice
	if f.Args != nil {
		elemMatchArgs := false
		for _, elem := range obj.Args {
			if f.Args.Eval(&elem) {
				elemMatchArgs = true
			}
		}

		if !elemMatchArgs {
			return false
		}

	}

	return true
}

func (f *FilterMsgAddPackage) Eval(obj *MsgAddPackage) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Send field
	toEvalSend := obj.Send
	if f.Send != nil && !f.Send.Eval(&toEvalSend) {
		return false
	}

	// Handle Package field
	toEvalPackage := obj.Package
	if f.Package != nil && !f.Package.Eval(toEvalPackage) {
		return false
	}

	// Handle MaxDeposit field
	toEvalMaxDeposit := obj.MaxDeposit
	if f.MaxDeposit != nil && !f.MaxDeposit.Eval(&toEvalMaxDeposit) {
		return false
	}

	// Handle Deposit field
	toEvalDeposit := obj.Deposit
	if f.Deposit != nil && !f.Deposit.Eval(&toEvalDeposit) {
		return false
	}

	// Handle Creator field
	toEvalCreator := obj.Creator
	if f.Creator != nil && !f.Creator.Eval(&toEvalCreator) {
		return false
	}

	return true
}

func (f *FilterMessageValue) Eval(obj *MessageValue) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Handle union objects depending of the type

	// Check if any filters are specified
	filtersSpecified := f.BankMsgSend != nil || f.MsgCall != nil || f.MsgAddPackage != nil || f.MsgRun != nil || false

	// If no filters are specified for any types, accept all objects
	if !filtersSpecified {
		return true
	}

	// Evaluate specified type filters
	matchedType := false

	tobj := *obj
	if uObj, ok := tobj.(BankMsgSend); ok {
		matchedType = true
		if f.BankMsgSend != nil && f.BankMsgSend.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*BankMsgSend); ok {
		matchedType = true
		if f.BankMsgSend != nil && f.BankMsgSend.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(MsgCall); ok {
		matchedType = true
		if f.MsgCall != nil && f.MsgCall.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*MsgCall); ok {
		matchedType = true
		if f.MsgCall != nil && f.MsgCall.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(MsgAddPackage); ok {
		matchedType = true
		if f.MsgAddPackage != nil && f.MsgAddPackage.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*MsgAddPackage); ok {
		matchedType = true
		if f.MsgAddPackage != nil && f.MsgAddPackage.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(MsgRun); ok {
		matchedType = true
		if f.MsgRun != nil && f.MsgRun.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*MsgRun); ok {
		matchedType = true
		if f.MsgRun != nil && f.MsgRun.Eval(uObj) {
			return true
		}
	}

	// If the object is of a type specified in filters but didn't match, return false.
	if matchedType {
		return false
	}

	return true
}

func (f *FilterMemPackage) Eval(obj *MemPackage) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Path field
	toEvalPath := obj.Path
	if f.Path != nil && !f.Path.Eval(&toEvalPath) {
		return false
	}

	// Handle Name field
	toEvalName := obj.Name
	if f.Name != nil && !f.Name.Eval(&toEvalName) {
		return false
	}

	// Handle Files slice
	if f.Files != nil {
		elemMatchFiles := false
		for _, elem := range obj.Files {
			if f.Files.Eval(elem) {
				elemMatchFiles = true
			}
		}

		if !elemMatchFiles {
			return false
		}

	}

	return true
}

func (f *FilterMemFile) Eval(obj *MemFile) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Name field
	toEvalName := obj.Name
	if f.Name != nil && !f.Name.Eval(&toEvalName) {
		return false
	}

	// Handle Body field
	toEvalBody := obj.Body
	if f.Body != nil && !f.Body.Eval(&toEvalBody) {
		return false
	}

	return true
}

func (f *FilterGnoEventAttribute) Eval(obj *GnoEventAttribute) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Value field
	toEvalValue := obj.Value
	if f.Value != nil && !f.Value.Eval(&toEvalValue) {
		return false
	}

	// Handle Key field
	toEvalKey := obj.Key
	if f.Key != nil && !f.Key.Eval(&toEvalKey) {
		return false
	}

	return true
}

func (f *FilterGnoEvent) Eval(obj *GnoEvent) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Type field
	toEvalType := obj.Type
	if f.Type != nil && !f.Type.Eval(&toEvalType) {
		return false
	}

	// Handle PkgPath field
	toEvalPkgPath := obj.PkgPath
	if f.PkgPath != nil && !f.PkgPath.Eval(&toEvalPkgPath) {
		return false
	}

	// Handle Func field
	toEvalFunc := obj.Func
	if f.Func != nil && !f.Func.Eval(&toEvalFunc) {
		return false
	}

	// Handle Attrs slice
	if f.Attrs != nil {
		elemMatchAttrs := false
		for _, elem := range obj.Attrs {
			if f.Attrs.Eval(elem) {
				elemMatchAttrs = true
			}
		}

		if !elemMatchAttrs {
			return false
		}

	}

	return true
}

func (f *FilterEvent) Eval(obj *Event) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Handle union objects depending of the type

	// Check if any filters are specified
	filtersSpecified := f.GnoEvent != nil || f.StorageDepositEvent != nil || f.StorageUnlockEvent != nil || f.UnknownEvent != nil || false

	// If no filters are specified for any types, accept all objects
	if !filtersSpecified {
		return true
	}

	// Evaluate specified type filters
	matchedType := false

	tobj := *obj
	if uObj, ok := tobj.(GnoEvent); ok {
		matchedType = true
		if f.GnoEvent != nil && f.GnoEvent.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*GnoEvent); ok {
		matchedType = true
		if f.GnoEvent != nil && f.GnoEvent.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(StorageDepositEvent); ok {
		matchedType = true
		if f.StorageDepositEvent != nil && f.StorageDepositEvent.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*StorageDepositEvent); ok {
		matchedType = true
		if f.StorageDepositEvent != nil && f.StorageDepositEvent.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(StorageUnlockEvent); ok {
		matchedType = true
		if f.StorageUnlockEvent != nil && f.StorageUnlockEvent.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*StorageUnlockEvent); ok {
		matchedType = true
		if f.StorageUnlockEvent != nil && f.StorageUnlockEvent.Eval(uObj) {
			return true
		}
	}

	if uObj, ok := tobj.(UnknownEvent); ok {
		matchedType = true
		if f.UnknownEvent != nil && f.UnknownEvent.Eval(&uObj) {
			return true
		}
	}
	if uObj, ok := tobj.(*UnknownEvent); ok {
		matchedType = true
		if f.UnknownEvent != nil && f.UnknownEvent.Eval(uObj) {
			return true
		}
	}

	// If the object is of a type specified in filters but didn't match, return false.
	if matchedType {
		return false
	}

	return true
}

func (f *FilterCoin) Eval(obj *Coin) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Denom field
	toEvalDenom := obj.Denom
	if f.Denom != nil && !f.Denom.Eval(&toEvalDenom) {
		return false
	}

	// Handle Amount field
	toEvalAmount := toIntPtr(obj.Amount)
	if f.Amount != nil && !f.Amount.Eval(toEvalAmount) {
		return false
	}

	return true
}

func (f *FilterBlockTransaction) Eval(obj *BlockTransaction) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Memo field
	toEvalMemo := obj.Memo
	if f.Memo != nil && !f.Memo.Eval(&toEvalMemo) {
		return false
	}

	// Handle Hash field
	toEvalHash := obj.Hash
	if f.Hash != nil && !f.Hash.Eval(&toEvalHash) {
		return false
	}

	// Handle Fee field
	toEvalFee := obj.Fee
	if f.Fee != nil && !f.Fee.Eval(toEvalFee) {
		return false
	}

	return true
}

func (f *FilterBlock) Eval(obj *Block) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle Version field
	toEvalVersion := obj.Version()
	if f.Version != nil && !f.Version.Eval(&toEvalVersion) {
		return false
	}

	// Handle ValidatorsHash field
	toEvalValidatorsHash := obj.ValidatorsHash()
	if f.ValidatorsHash != nil && !f.ValidatorsHash.Eval(&toEvalValidatorsHash) {
		return false
	}

	// Handle Txs slice
	if f.Txs != nil {
		elemMatchTxs := false
		for _, elem := range obj.Txs() {
			if f.Txs.Eval(elem) {
				elemMatchTxs = true
			}
		}

		if !elemMatchTxs {
			return false
		}

	}

	// Handle TotalTxs field
	toEvalTotalTxs := toIntPtr(obj.TotalTxs())
	if f.TotalTxs != nil && !f.TotalTxs.Eval(toEvalTotalTxs) {
		return false
	}

	// Handle Time field
	toEvalTime := obj.Time()
	if f.Time != nil && !f.Time.Eval(&toEvalTime) {
		return false
	}

	// Handle ProposerAddressRaw field
	toEvalProposerAddressRaw := obj.ProposerAddressRaw()
	if f.ProposerAddressRaw != nil && !f.ProposerAddressRaw.Eval(&toEvalProposerAddressRaw) {
		return false
	}

	// Handle NumTxs field
	toEvalNumTxs := toIntPtr(obj.NumTxs())
	if f.NumTxs != nil && !f.NumTxs.Eval(toEvalNumTxs) {
		return false
	}

	// Handle NextValidatorsHash field
	toEvalNextValidatorsHash := obj.NextValidatorsHash()
	if f.NextValidatorsHash != nil && !f.NextValidatorsHash.Eval(&toEvalNextValidatorsHash) {
		return false
	}

	// Handle LastResultsHash field
	toEvalLastResultsHash := obj.LastResultsHash()
	if f.LastResultsHash != nil && !f.LastResultsHash.Eval(&toEvalLastResultsHash) {
		return false
	}

	// Handle LastCommitHash field
	toEvalLastCommitHash := obj.LastCommitHash()
	if f.LastCommitHash != nil && !f.LastCommitHash.Eval(&toEvalLastCommitHash) {
		return false
	}

	// Handle LastBlockHash field
	toEvalLastBlockHash := obj.LastBlockHash()
	if f.LastBlockHash != nil && !f.LastBlockHash.Eval(&toEvalLastBlockHash) {
		return false
	}

	// Handle Height field
	toEvalHeight := toIntPtr(obj.Height())
	if f.Height != nil && !f.Height.Eval(toEvalHeight) {
		return false
	}

	// Handle Hash field
	toEvalHash := obj.Hash()
	if f.Hash != nil && !f.Hash.Eval(&toEvalHash) {
		return false
	}

	// Handle ConsensusHash field
	toEvalConsensusHash := obj.ConsensusHash()
	if f.ConsensusHash != nil && !f.ConsensusHash.Eval(&toEvalConsensusHash) {
		return false
	}

	// Handle ChainID field
	toEvalChainID := obj.ChainID()
	if f.ChainID != nil && !f.ChainID.Eval(&toEvalChainID) {
		return false
	}

	// Handle AppVersion field
	toEvalAppVersion := obj.AppVersion()
	if f.AppVersion != nil && !f.AppVersion.Eval(&toEvalAppVersion) {
		return false
	}

	// Handle AppHash field
	toEvalAppHash := obj.AppHash()
	if f.AppHash != nil && !f.AppHash.Eval(&toEvalAppHash) {
		return false
	}

	return true
}

// MinMax function for Height
func (f *FilterBlock) MinMaxHeight() (min *int, max *int) {
	// Recursively handle And conditions
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			subMin, subMax := subFilter.MinMaxHeight()
			if subMin != nil && (min == nil || *subMin < *min) {
				min = subMin
			}
			if subMax != nil && (max == nil || *subMax > *max) {
				max = subMax
			}
		}
	}

	// Recursively handle Or conditions
	if len(f.Or) > 0 {
		for _, subFilter := range f.Or {
			subMin, subMax := subFilter.MinMaxHeight()
			if subMin != nil && (min == nil || *subMin < *min) {
				min = subMin
			}
			if subMax != nil && (max == nil || *subMax > *max) {
				max = subMax
			}
		}
	}

	if f.Height != nil {
		if f.Height.Gt != nil {
			if min == nil || *f.Height.Gt < *min {
				min = f.Height.Gt
			}
		}

		if f.Height.Lt != nil {
			if max == nil || *f.Height.Lt > *max {
				max = f.Height.Lt
			}
		}

		if f.Height.Eq != nil {
			if min == nil || *f.Height.Eq < *min {
				min = f.Height.Eq
			}
			if max == nil || *f.Height.Eq > *max {
				max = f.Height.Eq
			}
		}
	}

	return min, max
}

func (f *FilterBankMsgSend) Eval(obj *BankMsgSend) bool {
	// Evaluate logical operators first
	if len(f.And) > 0 {
		for _, subFilter := range f.And {
			if !subFilter.Eval(obj) {
				return false
			}
		}
	}

	if len(f.Or) > 0 {
		orResult := false
		for _, subFilter := range f.Or {
			if subFilter.Eval(obj) {
				orResult = true
				break
			}
		}
		if !orResult {
			return false
		}
	}

	if f.Not != nil {
		if f.Not.Eval(obj) {
			return false
		}
	}

	// Evaluate individual field filters

	// Handle ToAddress field
	toEvalToAddress := obj.ToAddress
	if f.ToAddress != nil && !f.ToAddress.Eval(&toEvalToAddress) {
		return false
	}

	// Handle FromAddress field
	toEvalFromAddress := obj.FromAddress
	if f.FromAddress != nil && !f.FromAddress.Eval(&toEvalFromAddress) {
		return false
	}

	// Handle Amount field
	toEvalAmount := obj.Amount
	if f.Amount != nil && !f.Amount.Eval(&toEvalAmount) {
		return false
	}

	return true
}

func toIntPtr(val interface{}) *int {
	if val == nil {
		return nil
	}

	switch v := val.(type) {
	case int:
		return &v
	case int64:
		i := int(v)
		return &i
	case int32:
		i := int(v)
		return &i
	case int16:
		i := int(v)
		return &i
	case int8:
		i := int(v)
		return &i
	case *int:
		return v
	case *int64:
		i := int(*v)
		return &i
	case *int32:
		i := int(*v)
		return &i
	case *int16:
		i := int(*v)
		return &i
	case *int8:
		i := int(*v)
		return &i
	default:
		return nil
	}
}

///////////////////////////////// GENERIC TYPES /////////////////////////////////

func (f *FilterBoolean) Eval(val *bool) bool {
	if f == nil {
		return true
	}

	return rootEval(val, f.Exists, f.Eq)
}

func (f *FilterInt) Eval(val *int) bool {
	if f == nil {
		return true
	}

	if !rootEval(val, f.Exists, f.Eq) {
		return false
	}

	if val != nil && f.Gt != nil && *val <= *f.Gt {
		return false
	}

	if val != nil && f.Lt != nil && *val >= *f.Lt {
		return false
	}

	return true
}

func (f *FilterString) Eval(val *string) bool {
	if f == nil {
		return true
	}

	if !rootEval(val, f.Exists, f.Eq) {
		return false
	}

	if val != nil && f.Like != nil {
		matched, err := regexp.MatchString(*f.Like, *val)
		if err != nil || !matched {
			return false
		}
	}

	return true
}

// Eval evaluates the FilterTime conditions against a given time.Time value
func (f *FilterTime) Eval(val *time.Time) bool {
	if f == nil {
		return true
	}

	if !rootEval(val, f.Exists, f.Eq) {
		return false
	}

	// Check if the value is before the specified time
	if f.Before != nil && !val.Before(*f.Before) {
		return false
	}

	// Check if the value is after the specified time
	if f.After != nil && !val.After(*f.After) {
		return false
	}

	return true
}

// rootEval is a generic function that checks if the provided value matches the filter conditions.
func rootEval[T comparable](val *T, exists *bool, eq *T) bool {
	// Check the Exists filter
	if exists != nil {
		if *exists && val == nil {
			return false
		}
		if !*exists && val != nil {
			return false
		}
	}

	// If val is nil and we reach this point, skip the following checks
	if val == nil {
		return true
	}

	// Check the Eq filter
	if eq != nil && *eq != *val {
		return false
	}

	return true
}
