// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Event interface {
	IsEvent()
}

type MessageValue interface {
	IsMessageValue()
}

// `AmountInput` is a range of token quantities to filter by.
type AmountInput struct {
	// The minimum quantity of tokens to check for.
	From *int `json:"from,omitempty"`
	// The maximum quantity of tokens to check for.
	To *int `json:"to,omitempty"`
	// Filter by token's denomination.
	// If set to an empty string, it will get an empty value.
	Denomination *string `json:"denomination,omitempty"`
}

// `BankMsgSend` is a message with a message router of `bank` and a message type of `send`.
// `BankMsgSend` is the fund transfer tx message.
type BankMsgSend struct {
	// the bech32 address of the fund sender.
	// ex) `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5`
	FromAddress string `json:"from_address"`
	// the bech32 address of the fund receiver.
	// ex) `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5`
	ToAddress string `json:"to_address"`
	// the denomination and amount of fund sent ("<amount><denomination>").
	// ex) `1000000ugnot`
	Amount string `json:"amount"`
}

func (BankMsgSend) IsMessageValue() {}

// `BankMsgSendInput` represents input parameters required when the message type is `send`.
type BankMsgSendInput struct {
	// the bech32 address of the fund sender.
	// You can filter by the fund sender address.
	// ex) `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5`
	FromAddress *string `json:"from_address,omitempty"`
	// the bech32 address of the fund receiver.
	// You can filter by the fund receiver address.
	// ex) `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5`
	ToAddress *string `json:"to_address,omitempty"`
	// the denomination and amount of fund sent ("<amount><denomination>").
	// ex) `1000000ugnot`
	Amount *AmountInput `json:"amount,omitempty"`
}

// Filters for querying Blocks within specified criteria related to their attributes.
type BlockFilter struct {
	// Minimum block height from which to start fetching Blocks, inclusive. If unspecified, there is no lower bound.
	FromHeight *int `json:"from_height,omitempty"`
	// Maximum block height up to which Blocks should be fetched, exclusive. If unspecified, there is no upper bound.
	ToHeight *int `json:"to_height,omitempty"`
	// Minimum timestamp from which to start fetching Blocks, inclusive. Blocks created at or after this time will be included.
	FromTime *time.Time `json:"from_time,omitempty"`
	// Maximum timestamp up to which to fetch Blocks, exclusive. Only Blocks created before this time are included.
	ToTime *time.Time `json:"to_time,omitempty"`
}

type BlockOrder struct {
	Height Order `json:"height"`
}

// Defines a transaction within a block, its execution specifics and content.
type BlockTransaction struct {
	// Hash computes the TMHASH hash of the wire encoded transaction.
	Hash string `json:"hash"`
	// Fee information for the transaction.
	Fee *TxFee `json:"fee"`
	// `memo` are string information stored within a transaction.
	// `memo` can be utilized to find or distinguish transactions.
	// For example, when trading a specific exchange, you would utilize the memo field of the transaction.
	Memo string `json:"memo"`
	// The payload of the Transaction in a raw format, typically containing the instructions and any data necessary for execution.
	ContentRaw string `json:"content_raw"`
}

// Define the quantity and denomination of a coin.
type Coin struct {
	// The amount of coins.
	Amount int `json:"amount"`
	// The denomination of the coin.
	Denom string `json:"denom"`
}

// Transaction event's attribute to filter transaction.
// "EventAttributeInput" can be configured as a filter with a event attribute's `key` and `value`.
type EventAttributeInput struct {
	// `key` is the key of the event attribute.
	Key *string `json:"key,omitempty"`
	// `value` is the value of the event attribute.
	Value *string `json:"value,omitempty"`
}

// Transaction's event to filter transactions.
// "EventInput" can be configured as a filter with a transaction event's `type` and `pkg_path` and `func`, and `attrs`.
type EventInput struct {
	// `type` is the type of transaction event emitted.
	Type *string `json:"type,omitempty"`
	// `pkg_path` is the path to the package that emitted the event.
	PkgPath *string `json:"pkg_path,omitempty"`
	// `func` is the name of the function that emitted the event.
	Func *string `json:"func,omitempty"`
	// `attrs` filters transactions whose events contain attributes.
	// `attrs` is entered as an array and works exclusively.
	// ex) `attrs[0] || attrs[1] || attrs[2]`
	Attrs []*EventAttributeInput `json:"attrs,omitempty"`
}

// filter for BankMsgSend objects
type FilterBankMsgSend struct {
	// logical operator for BankMsgSend that will combine two or more conditions, returning true if all of them are true.
	And []*FilterBankMsgSend `json:"_and,omitempty"`
	// logical operator for BankMsgSend that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterBankMsgSend `json:"_or,omitempty"`
	// logical operator for BankMsgSend that will reverse conditions.
	Not *FilterBankMsgSend `json:"_not,omitempty"`
	// filter for from_address field.
	FromAddress *FilterString `json:"from_address,omitempty"`
	// filter for to_address field.
	ToAddress *FilterString `json:"to_address,omitempty"`
	// filter for amount field.
	Amount *FilterString `json:"amount,omitempty"`
}

// filter for Block objects
type FilterBlock struct {
	// logical operator for Block that will combine two or more conditions, returning true if all of them are true.
	And []*FilterBlock `json:"_and,omitempty"`
	// logical operator for Block that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterBlock `json:"_or,omitempty"`
	// logical operator for Block that will reverse conditions.
	Not *FilterBlock `json:"_not,omitempty"`
	// filter for hash field.
	Hash *FilterString `json:"hash,omitempty"`
	// filter for height field.
	Height *FilterInt `json:"height,omitempty"`
	// filter for version field.
	Version *FilterString `json:"version,omitempty"`
	// filter for chain_id field.
	ChainID *FilterString `json:"chain_id,omitempty"`
	// filter for time field.
	Time *FilterTime `json:"time,omitempty"`
	// filter for num_txs field.
	NumTxs *FilterInt `json:"num_txs,omitempty"`
	// filter for total_txs field.
	TotalTxs *FilterInt `json:"total_txs,omitempty"`
	// filter for app_version field.
	AppVersion *FilterString `json:"app_version,omitempty"`
	// filter for last_block_hash field.
	LastBlockHash *FilterString `json:"last_block_hash,omitempty"`
	// filter for last_commit_hash field.
	LastCommitHash *FilterString `json:"last_commit_hash,omitempty"`
	// filter for validators_hash field.
	ValidatorsHash *FilterString `json:"validators_hash,omitempty"`
	// filter for next_validators_hash field.
	NextValidatorsHash *FilterString `json:"next_validators_hash,omitempty"`
	// filter for consensus_hash field.
	ConsensusHash *FilterString `json:"consensus_hash,omitempty"`
	// filter for app_hash field.
	AppHash *FilterString `json:"app_hash,omitempty"`
	// filter for last_results_hash field.
	LastResultsHash *FilterString `json:"last_results_hash,omitempty"`
	// filter for proposer_address_raw field.
	ProposerAddressRaw *FilterString `json:"proposer_address_raw,omitempty"`
	// filter for txs field.
	Txs *NestedFilterBlockTransaction `json:"txs,omitempty"`
}

// filter for BlockTransaction objects
type FilterBlockTransaction struct {
	// logical operator for BlockTransaction that will combine two or more conditions, returning true if all of them are true.
	And []*FilterBlockTransaction `json:"_and,omitempty"`
	// logical operator for BlockTransaction that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterBlockTransaction `json:"_or,omitempty"`
	// logical operator for BlockTransaction that will reverse conditions.
	Not *FilterBlockTransaction `json:"_not,omitempty"`
	// filter for hash field.
	Hash *FilterString `json:"hash,omitempty"`
	// filter for fee field.
	Fee *NestedFilterTxFee `json:"fee,omitempty"`
	// filter for memo field.
	Memo *FilterString `json:"memo,omitempty"`
}

// Filter type for boolean fields. All added filters here are processed as AND operators.
type FilterBoolean struct {
	// Filter a boolean field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a boolean field checking if it is equals to the specified value.
	Eq *bool `json:"eq,omitempty"`
}

// filter for Coin objects
type FilterCoin struct {
	// logical operator for Coin that will combine two or more conditions, returning true if all of them are true.
	And []*FilterCoin `json:"_and,omitempty"`
	// logical operator for Coin that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterCoin `json:"_or,omitempty"`
	// logical operator for Coin that will reverse conditions.
	Not *FilterCoin `json:"_not,omitempty"`
	// filter for amount field.
	Amount *FilterInt `json:"amount,omitempty"`
	// filter for denom field.
	Denom *FilterString `json:"denom,omitempty"`
}

// filter for Event objects
type FilterEvent struct {
	// logical operator for Event that will combine two or more conditions, returning true if all of them are true.
	And []*FilterEvent `json:"_and,omitempty"`
	// logical operator for Event that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterEvent `json:"_or,omitempty"`
	// logical operator for Event that will reverse conditions.
	Not *FilterEvent `json:"_not,omitempty"`
	// filter for GnoEvent union type.
	GnoEvent *NestedFilterGnoEvent `json:"GnoEvent,omitempty"`
	// filter for UnknownEvent union type.
	UnknownEvent *NestedFilterUnknownEvent `json:"UnknownEvent,omitempty"`
}

// filter for GnoEvent objects
type FilterGnoEvent struct {
	// logical operator for GnoEvent that will combine two or more conditions, returning true if all of them are true.
	And []*FilterGnoEvent `json:"_and,omitempty"`
	// logical operator for GnoEvent that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterGnoEvent `json:"_or,omitempty"`
	// logical operator for GnoEvent that will reverse conditions.
	Not *FilterGnoEvent `json:"_not,omitempty"`
	// filter for type field.
	Type *FilterString `json:"type,omitempty"`
	// filter for pkg_path field.
	PkgPath *FilterString `json:"pkg_path,omitempty"`
	// filter for func field.
	Func *FilterString `json:"func,omitempty"`
	// filter for attrs field.
	Attrs *NestedFilterGnoEventAttribute `json:"attrs,omitempty"`
}

// filter for GnoEventAttribute objects
type FilterGnoEventAttribute struct {
	// logical operator for GnoEventAttribute that will combine two or more conditions, returning true if all of them are true.
	And []*FilterGnoEventAttribute `json:"_and,omitempty"`
	// logical operator for GnoEventAttribute that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterGnoEventAttribute `json:"_or,omitempty"`
	// logical operator for GnoEventAttribute that will reverse conditions.
	Not *FilterGnoEventAttribute `json:"_not,omitempty"`
	// filter for key field.
	Key *FilterString `json:"key,omitempty"`
	// filter for value field.
	Value *FilterString `json:"value,omitempty"`
}

// Filter type for number fields. All added filters here are processed as AND operators.
type FilterInt struct {
	// Filter a number field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a number field checking if it is equals to the specified value.
	Eq *int `json:"eq,omitempty"`
	// Filter a number field checking if it is greater than the specified value.
	Gt *int `json:"gt,omitempty"`
	// Filter a number field checking if it is less than the specified value.
	Lt *int `json:"lt,omitempty"`
}

// filter for MemFile objects
type FilterMemFile struct {
	// logical operator for MemFile that will combine two or more conditions, returning true if all of them are true.
	And []*FilterMemFile `json:"_and,omitempty"`
	// logical operator for MemFile that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterMemFile `json:"_or,omitempty"`
	// logical operator for MemFile that will reverse conditions.
	Not *FilterMemFile `json:"_not,omitempty"`
	// filter for name field.
	Name *FilterString `json:"name,omitempty"`
	// filter for body field.
	Body *FilterString `json:"body,omitempty"`
}

// filter for MemPackage objects
type FilterMemPackage struct {
	// logical operator for MemPackage that will combine two or more conditions, returning true if all of them are true.
	And []*FilterMemPackage `json:"_and,omitempty"`
	// logical operator for MemPackage that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterMemPackage `json:"_or,omitempty"`
	// logical operator for MemPackage that will reverse conditions.
	Not *FilterMemPackage `json:"_not,omitempty"`
	// filter for name field.
	Name *FilterString `json:"name,omitempty"`
	// filter for path field.
	Path *FilterString `json:"path,omitempty"`
	// filter for files field.
	Files *NestedFilterMemFile `json:"files,omitempty"`
}

// filter for MessageValue objects
type FilterMessageValue struct {
	// logical operator for MessageValue that will combine two or more conditions, returning true if all of them are true.
	And []*FilterMessageValue `json:"_and,omitempty"`
	// logical operator for MessageValue that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterMessageValue `json:"_or,omitempty"`
	// logical operator for MessageValue that will reverse conditions.
	Not *FilterMessageValue `json:"_not,omitempty"`
	// filter for BankMsgSend union type.
	BankMsgSend *NestedFilterBankMsgSend `json:"BankMsgSend,omitempty"`
	// filter for MsgCall union type.
	MsgCall *NestedFilterMsgCall `json:"MsgCall,omitempty"`
	// filter for MsgAddPackage union type.
	MsgAddPackage *NestedFilterMsgAddPackage `json:"MsgAddPackage,omitempty"`
	// filter for MsgRun union type.
	MsgRun *NestedFilterMsgRun `json:"MsgRun,omitempty"`
}

// filter for MsgAddPackage objects
type FilterMsgAddPackage struct {
	// logical operator for MsgAddPackage that will combine two or more conditions, returning true if all of them are true.
	And []*FilterMsgAddPackage `json:"_and,omitempty"`
	// logical operator for MsgAddPackage that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterMsgAddPackage `json:"_or,omitempty"`
	// logical operator for MsgAddPackage that will reverse conditions.
	Not *FilterMsgAddPackage `json:"_not,omitempty"`
	// filter for creator field.
	Creator *FilterString `json:"creator,omitempty"`
	// filter for package field.
	Package *NestedFilterMemPackage `json:"package,omitempty"`
	// filter for deposit field.
	Deposit *FilterString `json:"deposit,omitempty"`
}

// filter for MsgCall objects
type FilterMsgCall struct {
	// logical operator for MsgCall that will combine two or more conditions, returning true if all of them are true.
	And []*FilterMsgCall `json:"_and,omitempty"`
	// logical operator for MsgCall that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterMsgCall `json:"_or,omitempty"`
	// logical operator for MsgCall that will reverse conditions.
	Not *FilterMsgCall `json:"_not,omitempty"`
	// filter for caller field.
	Caller *FilterString `json:"caller,omitempty"`
	// filter for send field.
	Send *FilterString `json:"send,omitempty"`
	// filter for pkg_path field.
	PkgPath *FilterString `json:"pkg_path,omitempty"`
	// filter for func field.
	Func *FilterString `json:"func,omitempty"`
	// filter for args field.
	Args *FilterString `json:"args,omitempty"`
}

// filter for MsgRun objects
type FilterMsgRun struct {
	// logical operator for MsgRun that will combine two or more conditions, returning true if all of them are true.
	And []*FilterMsgRun `json:"_and,omitempty"`
	// logical operator for MsgRun that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterMsgRun `json:"_or,omitempty"`
	// logical operator for MsgRun that will reverse conditions.
	Not *FilterMsgRun `json:"_not,omitempty"`
	// filter for caller field.
	Caller *FilterString `json:"caller,omitempty"`
	// filter for send field.
	Send *FilterString `json:"send,omitempty"`
	// filter for package field.
	Package *NestedFilterMemPackage `json:"package,omitempty"`
}

// Filter type for string fields. It contains a variety of filter types for string types. All added filters here are processed as AND operators.
type FilterString struct {
	// Filter a string field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a string field checking if it is equals to the specified value.
	Eq *string `json:"eq,omitempty"`
	// Filter a string field checking if it is like the specified value. You can use standard Go RegEx expressions here.
	Like *string `json:"like,omitempty"`
}

// Filter type for time fields. All added filters here are processed as AND operators.
type FilterTime struct {
	// Filter a time field checking if it exists or not.
	Exists *bool `json:"exists,omitempty"`
	// Filter a time field checking if it is equals to the specified value.
	Eq *time.Time `json:"eq,omitempty"`
	// Filter a time field checking if it is before than the specified value.
	Before *time.Time `json:"before,omitempty"`
	// Filter a time field checking if it is after the specified value.
	After *time.Time `json:"after,omitempty"`
}

// filter for Transaction objects
type FilterTransaction struct {
	// logical operator for Transaction that will combine two or more conditions, returning true if all of them are true.
	And []*FilterTransaction `json:"_and,omitempty"`
	// logical operator for Transaction that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterTransaction `json:"_or,omitempty"`
	// logical operator for Transaction that will reverse conditions.
	Not *FilterTransaction `json:"_not,omitempty"`
	// filter for index field.
	Index *FilterInt `json:"index,omitempty"`
	// filter for hash field.
	Hash *FilterString `json:"hash,omitempty"`
	// filter for success field.
	Success *FilterBoolean `json:"success,omitempty"`
	// filter for block_height field.
	BlockHeight *FilterInt `json:"block_height,omitempty"`
	// filter for gas_wanted field.
	GasWanted *FilterInt `json:"gas_wanted,omitempty"`
	// filter for gas_used field.
	GasUsed *FilterInt `json:"gas_used,omitempty"`
	// filter for gas_fee field.
	GasFee *NestedFilterCoin `json:"gas_fee,omitempty"`
	// filter for messages field.
	Messages *NestedFilterTransactionMessage `json:"messages,omitempty"`
	// filter for memo field.
	Memo *FilterString `json:"memo,omitempty"`
	// filter for response field.
	Response *NestedFilterTransactionResponse `json:"response,omitempty"`
}

// filter for TransactionMessage objects
type FilterTransactionMessage struct {
	// logical operator for TransactionMessage that will combine two or more conditions, returning true if all of them are true.
	And []*FilterTransactionMessage `json:"_and,omitempty"`
	// logical operator for TransactionMessage that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterTransactionMessage `json:"_or,omitempty"`
	// logical operator for TransactionMessage that will reverse conditions.
	Not *FilterTransactionMessage `json:"_not,omitempty"`
	// filter for typeUrl field.
	TypeURL *FilterString `json:"typeUrl,omitempty"`
	// filter for route field.
	Route *FilterString `json:"route,omitempty"`
	// filter for value field.
	Value *NestedFilterMessageValue `json:"value,omitempty"`
}

// filter for TransactionResponse objects
type FilterTransactionResponse struct {
	// logical operator for TransactionResponse that will combine two or more conditions, returning true if all of them are true.
	And []*FilterTransactionResponse `json:"_and,omitempty"`
	// logical operator for TransactionResponse that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterTransactionResponse `json:"_or,omitempty"`
	// logical operator for TransactionResponse that will reverse conditions.
	Not *FilterTransactionResponse `json:"_not,omitempty"`
	// filter for log field.
	Log *FilterString `json:"log,omitempty"`
	// filter for info field.
	Info *FilterString `json:"info,omitempty"`
	// filter for error field.
	Error *FilterString `json:"error,omitempty"`
	// filter for data field.
	Data *FilterString `json:"data,omitempty"`
	// filter for events field.
	Events *NestedFilterEvent `json:"events,omitempty"`
}

// filter for TxFee objects
type FilterTxFee struct {
	// logical operator for TxFee that will combine two or more conditions, returning true if all of them are true.
	And []*FilterTxFee `json:"_and,omitempty"`
	// logical operator for TxFee that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterTxFee `json:"_or,omitempty"`
	// logical operator for TxFee that will reverse conditions.
	Not *FilterTxFee `json:"_not,omitempty"`
	// filter for gas_wanted field.
	GasWanted *FilterInt `json:"gas_wanted,omitempty"`
	// filter for gas_fee field.
	GasFee *NestedFilterCoin `json:"gas_fee,omitempty"`
}

// filter for UnknownEvent objects
type FilterUnknownEvent struct {
	// logical operator for UnknownEvent that will combine two or more conditions, returning true if all of them are true.
	And []*FilterUnknownEvent `json:"_and,omitempty"`
	// logical operator for UnknownEvent that will combine two or more conditions, returning true if at least one of them is true.
	Or []*FilterUnknownEvent `json:"_or,omitempty"`
	// logical operator for UnknownEvent that will reverse conditions.
	Not *FilterUnknownEvent `json:"_not,omitempty"`
	// filter for value field.
	Value *FilterString `json:"value,omitempty"`
}

// `GnoEvent` is the event information exported by the Gno VM.
// It has `type`, `pkg_path`, `func`, and `attrs`.
type GnoEvent struct {
	// `type` is the type of transaction event emitted.
	Type string `json:"type"`
	// `pkg_path` is the path to the package that emitted the event.
	PkgPath string `json:"pkg_path"`
	// `func` is the name of the function that emitted the event.
	Func string `json:"func"`
	// `attrs` is the event's attribute information.
	Attrs []*GnoEventAttribute `json:"attrs,omitempty"`
}

func (GnoEvent) IsEvent() {}

// `GnoEventAttribute` is the attributes that the event has.
// It has `key` and `value`.
type GnoEventAttribute struct {
	// The key of the event attribute.
	Key string `json:"key"`
	// The value of the event attribute.
	Value string `json:"value"`
}

// `MemFile` is the metadata information tied to a single gno package / realm file
type MemFile struct {
	// the name of the source file.
	Name string `json:"name"`
	// the content of the source file.
	Body string `json:"body"`
}

// `MemFileInput` is the metadata information tied to a single gno package / realm file.
type MemFileInput struct {
	// the name of the source file.
	Name *string `json:"name,omitempty"`
	// the content of the source file.
	Body *string `json:"body,omitempty"`
}

// `MemPackage` is the metadata information tied to package / realm deployment.
type MemPackage struct {
	// the name of the package.
	Name string `json:"name"`
	// the gno path of the package.
	Path string `json:"path"`
	// the associated package gno source.
	Files []*MemFile `json:"files,omitempty"`
}

// `MemPackageInput` represents a package stored in memory.
type MemPackageInput struct {
	// the name of the package.
	Name *string `json:"name,omitempty"`
	// the gno path of the package.
	Path *string `json:"path,omitempty"`
	// the associated package gno source.
	Files []*MemFileInput `json:"files,omitempty"`
}

// `MsgAddPackage` is a message with a message router of `vm` and a message type of `add_package`.
// `MsgAddPackage` is the package deployment tx message.
type MsgAddPackage struct {
	// the bech32 address of the package deployer.
	// ex) `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5`
	Creator string `json:"creator"`
	// the package being deployed.
	Package *MemPackage `json:"package"`
	// the amount of funds to be deposited at deployment, if any ("<amount><denomination>").
	// ex) `1000000ugnot`
	Deposit string `json:"deposit"`
}

func (MsgAddPackage) IsMessageValue() {}

// `MsgAddPackageInput` represents input parameters required when the message type is `add_package`.
type MsgAddPackageInput struct {
	// the bech32 address of the package deployer.
	// You can filter by the package deployer's address.
	// ex) `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5`
	Creator *string `json:"creator,omitempty"`
	// the package being deployed.
	Package *MemPackageInput `json:"package,omitempty"`
	// the amount of funds to be deposited at deployment, if any ("<amount><denomination>").
	// ex) `1000000ugnot`
	Deposit *AmountInput `json:"deposit,omitempty"`
}

// `MsgCall` is a message with a message router of `vm` and a message type of `exec`.
// `MsgCall` is the method invocation tx message.
type MsgCall struct {
	// the bech32 address of the function caller.
	// ex) `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5`
	Caller string `json:"caller"`
	// the amount of funds to be deposited to the package, if any ("<amount><denomination>").
	// ex) `1000000ugnot`
	Send string `json:"send"`
	// the gno package path.
	PkgPath string `json:"pkg_path"`
	// the function name being invoked.
	Func string `json:"func"`
	// `args` are the arguments passed to the executed function.
	Args []string `json:"args,omitempty"`
}

func (MsgCall) IsMessageValue() {}

// `MsgCallInput` represents input parameters required when the message type is `exec`.
type MsgCallInput struct {
	// the bech32 address of the function caller.
	// You can filter by the function caller's address.
	// ex) `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5`
	Caller *string `json:"caller,omitempty"`
	// the amount of funds to be deposited to the package, if any ("<amount><denomination>").
	// ex) `1000000ugnot`
	Send *AmountInput `json:"send,omitempty"`
	// the gno package path.
	PkgPath *string `json:"pkg_path,omitempty"`
	// the function name being invoked.
	Func *string `json:"func,omitempty"`
	// `args` are the arguments passed to the executed function.
	// The arguments are checked in the order of the argument array and
	// if they are empty strings, they are excluded from the filtering criteria.
	// ex) `["", "", "1"]` <- Empty strings skip the condition.
	Args []string `json:"args,omitempty"`
}

// `MsgRun` is a message with a message router of `vm` and a message type of `run`.
// `MsgRun is the execute arbitrary Gno code tx message`.
type MsgRun struct {
	// the bech32 address of the function caller.
	// ex) `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5`
	Caller string `json:"caller"`
	// the amount of funds to be deposited to the package, if any ("<amount><denomination>").
	// ex) `1000000ugnot`
	Send string `json:"send"`
	// the package being executed.
	Package *MemPackage `json:"package"`
}

func (MsgRun) IsMessageValue() {}

// `MsgRunInput` represents input parameters required when the message type is `run`.
type MsgRunInput struct {
	// the bech32 address of the function caller.
	// You can filter by the function caller's address.
	// ex) `g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5`
	Caller *string `json:"caller,omitempty"`
	// the amount of funds to be deposited to the package, if any ("<amount><denomination>").
	// ex) `1000000ugnot`
	Send *AmountInput `json:"send,omitempty"`
	// the package being executed.
	Package *MemPackageInput `json:"package,omitempty"`
}

// filter for BankMsgSend objects
type NestedFilterBankMsgSend struct {
	// logical operator for BankMsgSend that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterBankMsgSend `json:"_and,omitempty"`
	// logical operator for BankMsgSend that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterBankMsgSend `json:"_or,omitempty"`
	// logical operator for BankMsgSend that will reverse conditions.
	Not *NestedFilterBankMsgSend `json:"_not,omitempty"`
	// filter for from_address field.
	FromAddress *FilterString `json:"from_address,omitempty"`
	// filter for to_address field.
	ToAddress *FilterString `json:"to_address,omitempty"`
	// filter for amount field.
	Amount *FilterString `json:"amount,omitempty"`
}

// filter for BlockTransaction objects
type NestedFilterBlockTransaction struct {
	// logical operator for BlockTransaction that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterBlockTransaction `json:"_and,omitempty"`
	// logical operator for BlockTransaction that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterBlockTransaction `json:"_or,omitempty"`
	// logical operator for BlockTransaction that will reverse conditions.
	Not *NestedFilterBlockTransaction `json:"_not,omitempty"`
	// filter for hash field.
	Hash *FilterString `json:"hash,omitempty"`
	// filter for fee field.
	Fee *NestedFilterTxFee `json:"fee,omitempty"`
	// filter for memo field.
	Memo *FilterString `json:"memo,omitempty"`
}

// filter for Coin objects
type NestedFilterCoin struct {
	// logical operator for Coin that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterCoin `json:"_and,omitempty"`
	// logical operator for Coin that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterCoin `json:"_or,omitempty"`
	// logical operator for Coin that will reverse conditions.
	Not *NestedFilterCoin `json:"_not,omitempty"`
	// filter for amount field.
	Amount *FilterInt `json:"amount,omitempty"`
	// filter for denom field.
	Denom *FilterString `json:"denom,omitempty"`
}

// filter for Event objects
type NestedFilterEvent struct {
	// logical operator for Event that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterEvent `json:"_and,omitempty"`
	// logical operator for Event that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterEvent `json:"_or,omitempty"`
	// logical operator for Event that will reverse conditions.
	Not *NestedFilterEvent `json:"_not,omitempty"`
	// filter for GnoEvent union type.
	GnoEvent *NestedFilterGnoEvent `json:"GnoEvent,omitempty"`
	// filter for UnknownEvent union type.
	UnknownEvent *NestedFilterUnknownEvent `json:"UnknownEvent,omitempty"`
}

// filter for GnoEvent objects
type NestedFilterGnoEvent struct {
	// logical operator for GnoEvent that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterGnoEvent `json:"_and,omitempty"`
	// logical operator for GnoEvent that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterGnoEvent `json:"_or,omitempty"`
	// logical operator for GnoEvent that will reverse conditions.
	Not *NestedFilterGnoEvent `json:"_not,omitempty"`
	// filter for type field.
	Type *FilterString `json:"type,omitempty"`
	// filter for pkg_path field.
	PkgPath *FilterString `json:"pkg_path,omitempty"`
	// filter for func field.
	Func *FilterString `json:"func,omitempty"`
	// filter for attrs field.
	Attrs *NestedFilterGnoEventAttribute `json:"attrs,omitempty"`
}

// filter for GnoEventAttribute objects
type NestedFilterGnoEventAttribute struct {
	// logical operator for GnoEventAttribute that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterGnoEventAttribute `json:"_and,omitempty"`
	// logical operator for GnoEventAttribute that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterGnoEventAttribute `json:"_or,omitempty"`
	// logical operator for GnoEventAttribute that will reverse conditions.
	Not *NestedFilterGnoEventAttribute `json:"_not,omitempty"`
	// filter for key field.
	Key *FilterString `json:"key,omitempty"`
	// filter for value field.
	Value *FilterString `json:"value,omitempty"`
}

// filter for MemFile objects
type NestedFilterMemFile struct {
	// logical operator for MemFile that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterMemFile `json:"_and,omitempty"`
	// logical operator for MemFile that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterMemFile `json:"_or,omitempty"`
	// logical operator for MemFile that will reverse conditions.
	Not *NestedFilterMemFile `json:"_not,omitempty"`
	// filter for name field.
	Name *FilterString `json:"name,omitempty"`
	// filter for body field.
	Body *FilterString `json:"body,omitempty"`
}

// filter for MemPackage objects
type NestedFilterMemPackage struct {
	// logical operator for MemPackage that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterMemPackage `json:"_and,omitempty"`
	// logical operator for MemPackage that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterMemPackage `json:"_or,omitempty"`
	// logical operator for MemPackage that will reverse conditions.
	Not *NestedFilterMemPackage `json:"_not,omitempty"`
	// filter for name field.
	Name *FilterString `json:"name,omitempty"`
	// filter for path field.
	Path *FilterString `json:"path,omitempty"`
	// filter for files field.
	Files *NestedFilterMemFile `json:"files,omitempty"`
}

// filter for MessageValue objects
type NestedFilterMessageValue struct {
	// logical operator for MessageValue that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterMessageValue `json:"_and,omitempty"`
	// logical operator for MessageValue that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterMessageValue `json:"_or,omitempty"`
	// logical operator for MessageValue that will reverse conditions.
	Not *NestedFilterMessageValue `json:"_not,omitempty"`
	// filter for BankMsgSend union type.
	BankMsgSend *NestedFilterBankMsgSend `json:"BankMsgSend,omitempty"`
	// filter for MsgCall union type.
	MsgCall *NestedFilterMsgCall `json:"MsgCall,omitempty"`
	// filter for MsgAddPackage union type.
	MsgAddPackage *NestedFilterMsgAddPackage `json:"MsgAddPackage,omitempty"`
	// filter for MsgRun union type.
	MsgRun *NestedFilterMsgRun `json:"MsgRun,omitempty"`
}

// filter for MsgAddPackage objects
type NestedFilterMsgAddPackage struct {
	// logical operator for MsgAddPackage that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterMsgAddPackage `json:"_and,omitempty"`
	// logical operator for MsgAddPackage that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterMsgAddPackage `json:"_or,omitempty"`
	// logical operator for MsgAddPackage that will reverse conditions.
	Not *NestedFilterMsgAddPackage `json:"_not,omitempty"`
	// filter for creator field.
	Creator *FilterString `json:"creator,omitempty"`
	// filter for package field.
	Package *NestedFilterMemPackage `json:"package,omitempty"`
	// filter for deposit field.
	Deposit *FilterString `json:"deposit,omitempty"`
}

// filter for MsgCall objects
type NestedFilterMsgCall struct {
	// logical operator for MsgCall that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterMsgCall `json:"_and,omitempty"`
	// logical operator for MsgCall that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterMsgCall `json:"_or,omitempty"`
	// logical operator for MsgCall that will reverse conditions.
	Not *NestedFilterMsgCall `json:"_not,omitempty"`
	// filter for caller field.
	Caller *FilterString `json:"caller,omitempty"`
	// filter for send field.
	Send *FilterString `json:"send,omitempty"`
	// filter for pkg_path field.
	PkgPath *FilterString `json:"pkg_path,omitempty"`
	// filter for func field.
	Func *FilterString `json:"func,omitempty"`
	// filter for args field.
	Args *FilterString `json:"args,omitempty"`
}

// filter for MsgRun objects
type NestedFilterMsgRun struct {
	// logical operator for MsgRun that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterMsgRun `json:"_and,omitempty"`
	// logical operator for MsgRun that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterMsgRun `json:"_or,omitempty"`
	// logical operator for MsgRun that will reverse conditions.
	Not *NestedFilterMsgRun `json:"_not,omitempty"`
	// filter for caller field.
	Caller *FilterString `json:"caller,omitempty"`
	// filter for send field.
	Send *FilterString `json:"send,omitempty"`
	// filter for package field.
	Package *NestedFilterMemPackage `json:"package,omitempty"`
}

// filter for TransactionMessage objects
type NestedFilterTransactionMessage struct {
	// logical operator for TransactionMessage that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterTransactionMessage `json:"_and,omitempty"`
	// logical operator for TransactionMessage that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterTransactionMessage `json:"_or,omitempty"`
	// logical operator for TransactionMessage that will reverse conditions.
	Not *NestedFilterTransactionMessage `json:"_not,omitempty"`
	// filter for typeUrl field.
	TypeURL *FilterString `json:"typeUrl,omitempty"`
	// filter for route field.
	Route *FilterString `json:"route,omitempty"`
	// filter for value field.
	Value *NestedFilterMessageValue `json:"value,omitempty"`
}

// filter for TransactionResponse objects
type NestedFilterTransactionResponse struct {
	// logical operator for TransactionResponse that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterTransactionResponse `json:"_and,omitempty"`
	// logical operator for TransactionResponse that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterTransactionResponse `json:"_or,omitempty"`
	// logical operator for TransactionResponse that will reverse conditions.
	Not *NestedFilterTransactionResponse `json:"_not,omitempty"`
	// filter for log field.
	Log *FilterString `json:"log,omitempty"`
	// filter for info field.
	Info *FilterString `json:"info,omitempty"`
	// filter for error field.
	Error *FilterString `json:"error,omitempty"`
	// filter for data field.
	Data *FilterString `json:"data,omitempty"`
	// filter for events field.
	Events *NestedFilterEvent `json:"events,omitempty"`
}

// filter for TxFee objects
type NestedFilterTxFee struct {
	// logical operator for TxFee that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterTxFee `json:"_and,omitempty"`
	// logical operator for TxFee that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterTxFee `json:"_or,omitempty"`
	// logical operator for TxFee that will reverse conditions.
	Not *NestedFilterTxFee `json:"_not,omitempty"`
	// filter for gas_wanted field.
	GasWanted *FilterInt `json:"gas_wanted,omitempty"`
	// filter for gas_fee field.
	GasFee *NestedFilterCoin `json:"gas_fee,omitempty"`
}

// filter for UnknownEvent objects
type NestedFilterUnknownEvent struct {
	// logical operator for UnknownEvent that will combine two or more conditions, returning true if all of them are true.
	And []*NestedFilterUnknownEvent `json:"_and,omitempty"`
	// logical operator for UnknownEvent that will combine two or more conditions, returning true if at least one of them is true.
	Or []*NestedFilterUnknownEvent `json:"_or,omitempty"`
	// logical operator for UnknownEvent that will reverse conditions.
	Not *NestedFilterUnknownEvent `json:"_not,omitempty"`
	// filter for value field.
	Value *FilterString `json:"value,omitempty"`
}

// Root Query type to fetch data about Blocks and Transactions based on filters or retrieve the latest block height.
type Query struct {
}

// Subscriptions provide a way for clients to receive real-time updates about Transactions and Blocks based on specified filter criteria.
// Subscribers will only receive updates for events occurring after the subscription is established.
type Subscription struct {
}

// `TransactionBankMessageInput` represents input parameters required when the message router is `bank`.
type TransactionBankMessageInput struct {
	// send represents input parameters required when the message type is `send`.
	Send *BankMsgSendInput `json:"send,omitempty"`
}

// Filters for querying Transactions within specified criteria related to their execution and placement within Blocks.
type TransactionFilter struct {
	// Minimum block height from which to start fetching Transactions, inclusive. Aids in scoping the search to recent Transactions.
	FromBlockHeight *int `json:"from_block_height,omitempty"`
	// Maximum block height up to which Transactions should be fetched, exclusive. Helps in limiting the search to older Transactions.
	ToBlockHeight *int `json:"to_block_height,omitempty"`
	// Minimum Transaction index from which to start fetching, inclusive. Facilitates ordering in Transaction queries.
	FromIndex *int `json:"from_index,omitempty"`
	// Maximum Transaction index up to which to fetch, exclusive. Ensures a limit on the ordering range for Transaction queries.
	ToIndex *int `json:"to_index,omitempty"`
	// Minimum `gas_wanted` value to filter Transactions by, inclusive. Filters Transactions based on the minimum computational effort declared.
	FromGasWanted *int `json:"from_gas_wanted,omitempty"`
	// Maximum `gas_wanted` value for filtering Transactions, exclusive. Limits Transactions based on the declared computational effort.
	ToGasWanted *int `json:"to_gas_wanted,omitempty"`
	// Minimum `gas_used` value to filter Transactions by, inclusive. Selects Transactions based on the minimum computational effort actually used.
	FromGasUsed *int `json:"from_gas_used,omitempty"`
	// Maximum `gas_used` value for filtering Transactions, exclusive. Refines selection based on the computational effort actually consumed.
	ToGasUsed *int `json:"to_gas_used,omitempty"`
	// Hash from Transaction content in base64 encoding. If this filter is used, any other filter will be ignored.
	Hash *string `json:"hash,omitempty"`
	// Transaction's messages to filter Transactions.
	// `message` can be configured as a filter with a transaction message's `router` and `type` and `parameters(bank / vm)`.
	// `message` is entered as an array and works exclusively.
	// ex) `message[0] || message[1] || message[2]`
	Message []*TransactionMessageInput `json:"message,omitempty"`
	// `memo` are string information stored within a transaction.
	// `memo` can be utilized to find or distinguish transactions.
	// For example, when trading a specific exchange, you would utilize the memo field of the transaction.
	Memo *string `json:"memo,omitempty"`
	// `success` is whether the transaction was successful or not.
	// `success` enables you to filter between successful and unsuccessful transactions.
	Success *bool `json:"success,omitempty"`
	// `events` are what the transaction has emitted.
	// `events` can be filtered with a specific event to query its transactions.
	// `events` is entered as an array and works exclusively.
	// ex) `events[0] || events[1] || events[2]`
	Events []*EventInput `json:"events,omitempty"`
}

// Transaction's message to filter Transactions.
// `TransactionMessageInput` can be configured as a filter with a transaction message's `router` and `type` and `parameters(bank / vm)`.
type TransactionMessageInput struct {
	// The type of transaction message.
	// The value of `typeUrl` can be `send`, `exec`, `add_package`, `run`.
	TypeURL *MessageType `json:"type_url,omitempty"`
	// The route of transaction message.
	// The value of `route` can be `bank`, `vm`.
	Route *MessageRoute `json:"route,omitempty"`
	// `TransactionBankMessageInput` represents input parameters required when the message router is `bank`.
	BankParam *TransactionBankMessageInput `json:"bank_param,omitempty"`
	// `TransactionVmMessageInput` represents input parameters required when the message router is `vm`.
	VMParam *TransactionVMMessageInput `json:"vm_param,omitempty"`
}

type TransactionOrder struct {
	HeightAndIndex Order `json:"heightAndIndex"`
}

// `TransactionVmMessageInput` represents input parameters required when the message router is `vm`.
type TransactionVMMessageInput struct {
	// `MsgCallInput` represents input parameters required when the message type is `exec`.
	Exec *MsgCallInput `json:"exec,omitempty"`
	// `MsgAddPackageInput` represents input parameters required when the message type is `add_package`.
	AddPackage *MsgAddPackageInput `json:"add_package,omitempty"`
	// `MsgRunInput` represents input parameters required when the message type is `run`.
	Run *MsgRunInput `json:"run,omitempty"`
}

// The `TxFee` has information about the fee used in the transaction and the maximum gas fee specified by the user.
type TxFee struct {
	// gas limit
	GasWanted int `json:"gas_wanted"`
	// The gas fee in the transaction.
	GasFee *Coin `json:"gas_fee"`
}

// `UnexpectedMessage` is an Undefined Message, which is a message that decoding failed.
type UnexpectedMessage struct {
	Raw string `json:"raw"`
}

func (UnexpectedMessage) IsMessageValue() {}

// `UnknownEvent` is an unknown event type.
// It has `value`.
type UnknownEvent struct {
	// `value` is a raw event string.
	Value string `json:"value"`
}

func (UnknownEvent) IsEvent() {}

type FilterableExtra string

const (
	// Get minimum and maximum value used on all the filters for this field.
	// Useful when you need to do a range query for performance reasons.
	FilterableExtraMinmax FilterableExtra = "MINMAX"
)

var AllFilterableExtra = []FilterableExtra{
	FilterableExtraMinmax,
}

func (e FilterableExtra) IsValid() bool {
	switch e {
	case FilterableExtraMinmax:
		return true
	}
	return false
}

func (e FilterableExtra) String() string {
	return string(e)
}

func (e *FilterableExtra) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FilterableExtra(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FilterableExtra", str)
	}
	return nil
}

func (e FilterableExtra) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// `MessageRoute` is route type of the transactional message.
// `MessageRoute` has the values of vm and bank.
type MessageRoute string

const (
	MessageRouteVM   MessageRoute = "vm"
	MessageRouteBank MessageRoute = "bank"
)

var AllMessageRoute = []MessageRoute{
	MessageRouteVM,
	MessageRouteBank,
}

func (e MessageRoute) IsValid() bool {
	switch e {
	case MessageRouteVM, MessageRouteBank:
		return true
	}
	return false
}

func (e MessageRoute) String() string {
	return string(e)
}

func (e *MessageRoute) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MessageRoute(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MessageRoute", str)
	}
	return nil
}

func (e MessageRoute) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// `MessageType` is message type of the transaction.
// `MessageType` has the values `send`, `exec`, `add_package`, and `run`.
type MessageType string

const (
	// The route value for this message type is `bank`, and the value for transactional messages is `BankMsgSend`.
	// This is a transaction message used when sending native tokens.
	MessageTypeSend MessageType = "send"
	// The route value for this message type is `vm`, and the value for transactional messages is `MsgCall`.
	// This is a transaction message that executes a function in realm or package that is deployed in the GNO chain.
	MessageTypeExec MessageType = "exec"
	// The route value for this message type is `vm`, and the value for transactional messages is `MsgAddPackage`.
	// This is a transactional message that adds a package to the GNO chain.
	MessageTypeAddPackage MessageType = "add_package"
	// The route value for this message type is `vm`, and the value for transactional messages is `MsgRun`.
	// This is a transactional message that executes an arbitrary Gno-coded TX message.
	MessageTypeRun MessageType = "run"
)

var AllMessageType = []MessageType{
	MessageTypeSend,
	MessageTypeExec,
	MessageTypeAddPackage,
	MessageTypeRun,
}

func (e MessageType) IsValid() bool {
	switch e {
	case MessageTypeSend, MessageTypeExec, MessageTypeAddPackage, MessageTypeRun:
		return true
	}
	return false
}

func (e MessageType) String() string {
	return string(e)
}

func (e *MessageType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MessageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MessageType", str)
	}
	return nil
}

func (e MessageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Order defines the output order for hte method, It can be in DESC (descending) or ASC (ascending) order.
type Order string

const (
	OrderAsc  Order = "ASC"
	OrderDesc Order = "DESC"
)

var AllOrder = []Order{
	OrderAsc,
	OrderDesc,
}

func (e Order) IsValid() bool {
	switch e {
	case OrderAsc, OrderDesc:
		return true
	}
	return false
}

func (e Order) String() string {
	return string(e)
}

func (e *Order) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Order(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Order", str)
	}
	return nil
}

func (e Order) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
